<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/proyectoZapateria/data/local/region/RegionEntity.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/proyectoZapateria/data/local/region/RegionEntity.kt" />
              <option name="originalContent" value="package com.example.proyectoZapateria.data.local.region&#10;&#10;import androidx.room.ColumnInfo&#10;import androidx.room.Entity&#10;import androidx.room.Index&#10;import androidx.room.PrimaryKey&#10;&#10;/**&#10; * Nota: Esta entidad está marcada como obsoleta.&#10; * La geografía (regiones/ciudades/comunas) ahora se obtiene desde el microservicio remoto&#10; * y las tablas locales se eliminaron del esquema de Room en `AppDatabase`.&#10; * Conservamos la clase por compatibilidad temporal; puede ser eliminada en una limpieza futura.&#10; */&#10;@Deprecated(&quot;Reemplazado por geografía remota - mantener temporalmente para compatibilidad&quot;)&#10;@Suppress(&quot;unused&quot;)&#10;@Entity(&#10;    tableName = &quot;region&quot;,&#10;    indices = [Index(value = [&quot;nombre_region&quot;], unique = true)]&#10;)&#10;data class RegionEntity(&#10;    @PrimaryKey(autoGenerate = true)&#10;    @ColumnInfo(name = &quot;id_region&quot;)&#10;    val idRegion: Int = 0,&#10;&#10;    @ColumnInfo(name = &quot;nombre_region&quot;)&#10;    val nombreRegion: String,&#10;&#10;    val abreviatura: String?&#10;)" />
              <option name="updatedContent" value="package com.example.proyectoZapateria.data.local.region&#10;&#10;import androidx.room.ColumnInfo&#10;import androidx.room.Entity&#10;import androidx.room.Index&#10;import androidx.room.PrimaryKey&#10;&#10;/**&#10; * Nota: Esta entidad está marcada como obsoleta.&#10; * La geografía (regiones/ciudades/comunas) ahora se obtiene desde el microservicio remoto&#10; * y las tablas locales se eliminaron del esquema de Room en `AppDatabase`.&#10; * Conservamos la clase por compatibilidad temporal; puede ser eliminada en una limpieza futura.&#10; */&#10;@Deprecated(&quot;Reemplazado por geografía remota - mantener temporalmente para compatibilidad&quot;)&#10;@Suppress(&quot;unused&quot;)&#10;@Entity(&#10;    tableName = &quot;region&quot;,&#10;    indices = [Index(value = [&quot;nombre_region&quot;], unique = true)]&#10;)&#10;data class RegionEntity(&#10;    @PrimaryKey(autoGenerate = true)&#10;    @ColumnInfo(name = &quot;id_region&quot;)&#10;    val idRegion: Int = 0,&#10;&#10;    @ColumnInfo(name = &quot;nombre_region&quot;)&#10;    val nombreRegion: String,&#10;&#10;    val abreviatura: String?&#10;)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/proyectoZapateria/viewmodel/cliente/ClientePerfilViewModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/proyectoZapateria/viewmodel/cliente/ClientePerfilViewModel.kt" />
              <option name="originalContent" value="package com.example.proyectoZapateria.viewmodel.cliente&#10;&#10;import android.content.Context&#10;import android.net.Uri&#10;import android.util.Log&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import com.example.proyectoZapateria.data.repository.remote.AuthRemoteRepository&#10;import com.example.proyectoZapateria.data.repository.remote.PersonaRemoteRepository&#10;import com.example.proyectoZapateria.data.repository.remote.ClienteRemoteRepository&#10;import com.example.proyectoZapateria.data.repository.remote.VentasRemoteRepository&#10;import com.example.proyectoZapateria.data.localstorage.SessionPreferences&#10;import com.example.proyectoZapateria.data.remote.usuario.dto.PersonaDTO&#10;import com.example.proyectoZapateria.data.repository.remote.UsuarioRemoteRepository&#10;import com.example.proyectoZapateria.domain.validation.validateProfileEmail&#10;import com.example.proyectoZapateria.domain.validation.validateProfileName&#10;import com.example.proyectoZapateria.domain.validation.validateProfilePhone&#10;import com.example.proyectoZapateria.domain.validation.validateProfileStreet&#10;import com.example.proyectoZapateria.domain.validation.validateProfileHouseNumber&#10;import dagger.hilt.android.lifecycle.HiltViewModel&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.launch&#10;import kotlinx.coroutines.withContext&#10;import okhttp3.MediaType.Companion.toMediaTypeOrNull&#10;import okhttp3.MediaType.Companion.toMediaTypeOrNull&#10;import okhttp3.RequestBody.Companion.asRequestBody&#10;import java.io.File&#10;import javax.inject.Inject&#10;&#10;@HiltViewModel&#10;class ClientePerfilViewModel @Inject constructor(&#10;    private val clienteRemoteRepository: ClienteRemoteRepository,&#10;    private val personaRemoteRepository: PersonaRemoteRepository,&#10;    private val authRemoteRepository: AuthRemoteRepository,&#10;    private val ventasRemoteRepository: VentasRemoteRepository,&#10;    private val usuarioRemoteRepository: UsuarioRemoteRepository,&#10;    private val sessionPreferences: SessionPreferences&#10;) : ViewModel() {&#10;&#10;    private val _uiState = MutableStateFlow(ClientePerfilUiState())&#10;    val uiState: StateFlow&lt;ClientePerfilUiState&gt; = _uiState.asStateFlow()&#10;&#10;    // Estado de edición y campos editables&#10;    private val _isEditing = MutableStateFlow(false)&#10;    val isEditing = _isEditing.asStateFlow()&#10;&#10;    private val _editNombre = MutableStateFlow(&quot;&quot;)&#10;    private val _editApellido = MutableStateFlow(&quot;&quot;)&#10;    private val _editEmail = MutableStateFlow(&quot;&quot;)&#10;    private val _editTelefono = MutableStateFlow(&quot;&quot;)&#10;    private val _editCalle = MutableStateFlow(&quot;&quot;)&#10;    private val _editNumeroPuerta = MutableStateFlow(&quot;&quot;)&#10;&#10;    val editNombre = _editNombre.asStateFlow()&#10;    val editApellido = _editApellido.asStateFlow()&#10;    val editEmail = _editEmail.asStateFlow()&#10;    val editTelefono = _editTelefono.asStateFlow()&#10;    val editCalle = _editCalle.asStateFlow()&#10;    val editNumeroPuerta = _editNumeroPuerta.asStateFlow()&#10;&#10;    private var personaActual: PersonaDTO? = null&#10;&#10;    private val _profileImageUri = MutableStateFlow&lt;Uri?&gt;(null)&#10;    val profileImageUri: StateFlow&lt;Uri?&gt; = _profileImageUri.asStateFlow()&#10;&#10;    data class PhotoLoadTrigger(val idPersona: Long, val timestamp: Long = System.currentTimeMillis())&#10;&#10;    private val _needsPhotoLoad = MutableStateFlow&lt;PhotoLoadTrigger?&gt;(null)&#10;    val needsPhotoLoad: StateFlow&lt;PhotoLoadTrigger?&gt; = _needsPhotoLoad.asStateFlow()&#10;&#10;    init {&#10;        cargarPerfil()&#10;    }&#10;&#10;&#10;    private fun cargarPerfil() {&#10;        viewModelScope.launch {&#10;            try {&#10;                _uiState.value = _uiState.value.copy(isLoading = true, error = null)&#10;&#10;                val currentUser = authRemoteRepository.currentUser.value&#10;                if (currentUser == null) {&#10;                    _uiState.value = _uiState.value.copy(isLoading = false, error = &quot;No hay sesión activa&quot;)&#10;                    return@launch&#10;                }&#10;&#10;                val idPersona = currentUser.idPersona&#10;&#10;                // Obtener datos del cliente desde API remota&#10;                val clienteResult = clienteRemoteRepository.obtenerClientePorId(idPersona)&#10;                val personaResult = personaRemoteRepository.obtenerPersonaPorId(idPersona)&#10;&#10;                if (clienteResult.isSuccess &amp;&amp; personaResult.isSuccess) {&#10;                    val cliente = clienteResult.getOrNull()&#10;                    val persona = personaResult.getOrNull()&#10;&#10;                    if (cliente != null &amp;&amp; persona != null) {&#10;                        // Estadísticas: contar boletas del cliente (via remoto)&#10;                        var total = 0&#10;                        try {&#10;                            val boletasRes = ventasRemoteRepository.obtenerBoletasPorCliente(idPersona)&#10;                            if (boletasRes.isSuccess) {&#10;                                val boletas = boletasRes.getOrNull()&#10;                                total = boletas?.size ?: 0&#10;                            }&#10;                        } catch (e: Exception) {&#10;                            // si falla, mantenemos total = 0&#10;                            Log.w(&quot;ClientePerfilVM&quot;, &quot;No se pudo obtener boletas remotas: ${e.message}&quot;)&#10;                        }&#10;&#10;                        _uiState.value = ClientePerfilUiState(&#10;                            nombre = cliente.nombreCompleto ?: &quot;&quot;,&#10;                            email = cliente.email ?: &quot;&quot;,&#10;                            telefono = cliente.telefono ?: &quot;&quot;,&#10;                            categoria = cliente.categoria ?: &quot;&quot;,&#10;                            calle = persona.calle ?: &quot;&quot;,&#10;                            numeroPuerta = persona.numeroPuerta ?: &quot;&quot;,&#10;                            totalPedidos = total,&#10;                            isLoading = false&#10;                        )&#10;&#10;                        // Poblar campos editables&#10;                        personaActual = persona&#10;                        _editNombre.value = persona.nombre ?: &quot;&quot;&#10;                        _editApellido.value = persona.apellido ?: &quot;&quot;&#10;                        _editEmail.value = persona.email ?: &quot;&quot;&#10;                        _editTelefono.value = persona.telefono ?: &quot;&quot;&#10;                        _editCalle.value = persona.calle ?: &quot;&quot;&#10;                        _editNumeroPuerta.value = persona.numeroPuerta ?: &quot;&quot;&#10;&#10;                        // Marcar que necesita cargar la foto (con timestamp para forzar recarga)&#10;                        _needsPhotoLoad.value = PhotoLoadTrigger(idPersona)&#10;                    } else {&#10;                        _uiState.value = _uiState.value.copy(isLoading = false, error = &quot;No se encontró información del cliente o persona&quot;)&#10;                    }&#10;                } else {&#10;                    _uiState.value = _uiState.value.copy(isLoading = false, error = &quot;Error al obtener datos del cliente&quot;)&#10;                }&#10;            } catch (e: Exception) {&#10;                _uiState.value = _uiState.value.copy(isLoading = false, error = e.message ?: &quot;Error desconocido&quot;)&#10;            }&#10;        }&#10;    }&#10;&#10;    // Comienzo edición&#10;    fun startEdit() {&#10;        _isEditing.value = true&#10;    }&#10;&#10;    fun cancelEdit() {&#10;        // restaurar valores desde personaActual&#10;        personaActual?.let { p -&gt;&#10;            _editNombre.value = p.nombre ?: &quot;&quot;&#10;            _editApellido.value = p.apellido ?: &quot;&quot;&#10;            _editEmail.value = p.email ?: &quot;&quot;&#10;            _editTelefono.value = p.telefono ?: &quot;&quot;&#10;            _editCalle.value = p.calle ?: &quot;&quot;&#10;            _editNumeroPuerta.value = p.numeroPuerta ?: &quot;&quot;&#10;        }&#10;        _isEditing.value = false&#10;    }&#10;&#10;    fun updateEditField(nombre: String? = null, apellido: String? = null, email: String? = null, telefono: String? = null, calle: String? = null, numeroPuerta: String? = null) {&#10;        nombre?.let { _editNombre.value = it }&#10;        apellido?.let { _editApellido.value = it }&#10;        email?.let { _editEmail.value = it }&#10;        telefono?.let { _editTelefono.value = it }&#10;        calle?.let { _editCalle.value = it }&#10;        numeroPuerta?.let { _editNumeroPuerta.value = it }&#10;    }&#10;&#10;    // Guardar cambios en PersonaDTO usando API remota&#10;    fun guardarCambios(onResult: (Boolean, String?) -&gt; Unit) {&#10;        viewModelScope.launch {&#10;            try {&#10;                val persona = personaActual&#10;                if (persona == null) {&#10;                    onResult(false, &quot;No se encontró la persona&quot;)&#10;                    return@launch&#10;                }&#10;&#10;                val emailVal = _editEmail.value.trim()&#10;                val nuevoUsername = if (emailVal.isNotBlank()) emailVal else (persona.username ?: &quot;&quot;)&#10;&#10;                val actualizado = persona.copy(&#10;                    nombre = _editNombre.value.trim(),&#10;                    apellido = _editApellido.value.trim(),&#10;                    email = emailVal.ifBlank { null },&#10;                    telefono = _editTelefono.value.trim().ifBlank { null },&#10;                    calle = _editCalle.value.trim().ifBlank { null },&#10;                    numeroPuerta = _editNumeroPuerta.value.trim().ifBlank { null },&#10;                    username = nuevoUsername&#10;                )&#10;&#10;                // Validaciones: nombre, email, teléfono&#10;                val nombreVal = _editNombre.value.trim()&#10;                val nombreErr = validateProfileName(nombreVal)&#10;                if (nombreErr != null) { onResult(false, nombreErr); return@launch }&#10;&#10;                if (emailVal.isNotBlank()) {&#10;                    val emailErr = validateProfileEmail(emailVal)&#10;                    if (emailErr != null) { onResult(false, emailErr); return@launch }&#10;                    // Validación de email único lo debe hacer el backend&#10;                }&#10;&#10;                val telefonoVal = _editTelefono.value.trim()&#10;                val telErr = validateProfilePhone(telefonoVal)&#10;                if (telErr != null) { onResult(false, telErr); return@launch }&#10;&#10;                // Validar dirección&#10;                val calleVal = _editCalle.value.trim()&#10;                if (calleVal.isNotBlank()) {&#10;                    val calleErr = validateProfileStreet(calleVal)&#10;                    if (calleErr != null) { onResult(false, calleErr); return@launch }&#10;                }&#10;&#10;                val numeroPuertaVal = _editNumeroPuerta.value.trim()&#10;                if (numeroPuertaVal.isNotBlank()) {&#10;                    val numeroPuertaErr = validateProfileHouseNumber(numeroPuertaVal)&#10;                    if (numeroPuertaErr != null) { onResult(false, numeroPuertaErr); return@launch }&#10;                }&#10;&#10;                // Actualizar persona en el API remota&#10;                val res = personaRemoteRepository.actualizarPersona(persona.idPersona ?: 0, actualizado)&#10;                if (res.isSuccess) {&#10;                    // Actualizar sesión si el usuario visible cambió (nombre/email)&#10;                    val current = authRemoteRepository.currentUser.value&#10;                    if (current != null &amp;&amp; current.idPersona == persona.idPersona) {&#10;                        // Obtener usuario actualizado desde API&#10;                        val usuarioActualizadoResult = authRemoteRepository.obtenerUsuarioPorId(persona.idPersona)&#10;                        usuarioActualizadoResult.onSuccess { nuevoUsuario -&gt;&#10;                            authRemoteRepository.setCurrentUser(nuevoUsuario)&#10;                            // Actualizar DataStore/sessionPreferences con el nuevo username si cambió&#10;                            try {&#10;                                sessionPreferences.saveSession(&#10;                                    userId = nuevoUsuario.idPersona,&#10;                                    username = nuevoUsuario.username,&#10;                                    userRole = nuevoUsuario.nombreRol,&#10;                                    userRoleId = nuevoUsuario.idRol&#10;                                )&#10;                            } catch (_: Exception) {&#10;                                // no bloquear la operación por fallo en preferences&#10;                            }&#10;                        }&#10;                    }&#10;                    // refrescar UI local&#10;                    cargarPerfil()&#10;                    _isEditing.value = false&#10;                    onResult(true, null)&#10;                } else {&#10;                    onResult(false, res.exceptionOrNull()?.message ?: &quot;Error al guardar&quot;)&#10;                }&#10;            } catch (e: Exception) {&#10;                onResult(false, e.message)&#10;            }&#10;        }&#10;    }&#10;&#10;    fun onProfileImageSelected(context: Context, file: File) {&#10;        viewModelScope.launch {&#10;            try {&#10;                val currentUser = authRemoteRepository.currentUser.value&#10;                if (currentUser == null) {&#10;                    Log.e(&quot;ClientePerfilVM&quot;, &quot;No hay usuario autenticado&quot;)&#10;                    return@launch&#10;                }&#10;&#10;                _profileImageUri.value = Uri.fromFile(file)&#10;&#10;                // Comprimir la imagen antes de subir (máximo 1024x1024, calidad 80%)&#10;                val compressedFile = withContext(Dispatchers.IO) {&#10;                    com.example.proyectoZapateria.util.ImageCompressor.compressImageFromFile(&#10;                        context, file, maxWidth = 1024, maxHeight = 1024, quality = 80&#10;                    )&#10;                }&#10;&#10;                if (compressedFile == null) {&#10;                    Log.e(&quot;ClientePerfilVM&quot;, &quot;Error al comprimir imagen&quot;)&#10;                    return@launch&#10;                }&#10;&#10;                val requestFile = compressedFile.asRequestBody(&quot;image/*&quot;.toMediaTypeOrNull())&#10;                val fotoPart = okhttp3.MultipartBody.Part.createFormData(&#10;                    &quot;foto&quot;,&#10;                    compressedFile.name,&#10;                    requestFile&#10;                )&#10;&#10;                val result = usuarioRemoteRepository.subirFotoPerfil(currentUser.idPersona, fotoPart)&#10;&#10;                result.onSuccess {&#10;                    // Eliminar archivo comprimido temporal&#10;                    compressedFile.delete()&#10;                    kotlinx.coroutines.delay(500)&#10;                    cargarFotoPerfil(context, currentUser.idPersona)&#10;                }.onFailure { error -&gt;&#10;                    compressedFile.delete()&#10;                    Log.e(&quot;ClientePerfilVM&quot;, &quot;Error al subir foto: ${error.message}&quot;)&#10;                }&#10;            } catch (e: Exception) {&#10;                Log.e(&quot;ClientePerfilVM&quot;, &quot;Error al procesar imagen: ${e.message}&quot;)&#10;            }&#10;        }&#10;    }&#10;&#10;    // Cargar foto de perfil desde el servidor&#10;    fun cargarFotoPerfil(context: Context, idPersona: Long) {&#10;        viewModelScope.launch {&#10;            try {&#10;                Log.d(&quot;ClientePerfilVM&quot;, &quot;=== INICIO CARGA DE FOTO ===&quot;)&#10;                Log.d(&quot;ClientePerfilVM&quot;, &quot;ID Persona: $idPersona&quot;)&#10;&#10;                val result = usuarioRemoteRepository.obtenerFotoPerfil(idPersona)&#10;&#10;                result.onSuccess { fotoBytes -&gt;&#10;                    Log.d(&quot;ClientePerfilVM&quot;, &quot;Respuesta del servidor recibida&quot;)&#10;&#10;                    if (fotoBytes == null) {&#10;                        Log.w(&quot;ClientePerfilVM&quot;, &quot;⚠️ fotoBytes es NULL&quot;)&#10;                        return@onSuccess&#10;                    }&#10;&#10;                    if (fotoBytes.isEmpty()) {&#10;                        Log.w(&quot;ClientePerfilVM&quot;, &quot;⚠️ fotoBytes está VACÍO&quot;)&#10;                        return@onSuccess&#10;                    }&#10;&#10;                    Log.d(&quot;ClientePerfilVM&quot;, &quot;Tamaño de foto recibida: ${fotoBytes.size} bytes&quot;)&#10;&#10;                    // Eliminar archivo temporal anterior si existe&#10;                    _profileImageUri.value?.let { oldUri -&gt;&#10;                        try {&#10;                            val oldFile = File(oldUri.path ?: &quot;&quot;)&#10;                            if (oldFile.exists()) {&#10;                                oldFile.delete()&#10;                                Log.d(&quot;ClientePerfilVM&quot;, &quot;Archivo anterior eliminado: ${oldFile.absolutePath}&quot;)&#10;                            }&#10;                        } catch (e: Exception) {&#10;                            Log.w(&quot;ClientePerfilVM&quot;, &quot;No se pudo eliminar archivo anterior: ${e.message}&quot;)&#10;                        }&#10;                    }&#10;&#10;                    // Crear nuevo archivo con timestamp único para evitar caché&#10;                    val timestamp = System.currentTimeMillis()&#10;                    val tempFile = File(context.cacheDir, &quot;profile_${idPersona}_${timestamp}.jpg&quot;)&#10;                    tempFile.writeBytes(fotoBytes)&#10;&#10;                    Log.d(&quot;ClientePerfilVM&quot;, &quot;Nuevo archivo creado: ${tempFile.absolutePath}&quot;)&#10;&#10;                    _profileImageUri.value = Uri.fromFile(tempFile)&#10;                    _uiState.value = _uiState.value.copy(profileImageUri = tempFile.absolutePath)&#10;&#10;                    Log.d(&quot;ClientePerfilVM&quot;, &quot;✅ Foto cargada exitosamente y URI actualizado&quot;)&#10;                }.onFailure { error -&gt;&#10;                    Log.e(&quot;ClientePerfilVM&quot;, &quot;❌ Error al obtener foto del servidor: ${error.message}&quot;, error)&#10;                }&#10;            } catch (e: Exception) {&#10;                Log.e(&quot;ClientePerfilVM&quot;, &quot;❌ Excepción al cargar foto: ${e.message}&quot;, e)&#10;            }&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.proyectoZapateria.viewmodel.cliente&#10;&#10;import android.content.Context&#10;import android.net.Uri&#10;import android.util.Log&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import com.example.proyectoZapateria.data.repository.remote.AuthRemoteRepository&#10;import com.example.proyectoZapateria.data.repository.remote.PersonaRemoteRepository&#10;import com.example.proyectoZapateria.data.repository.remote.ClienteRemoteRepository&#10;import com.example.proyectoZapateria.data.repository.remote.VentasRemoteRepository&#10;import com.example.proyectoZapateria.data.localstorage.SessionPreferences&#10;import com.example.proyectoZapateria.data.remote.usuario.dto.PersonaDTO&#10;import com.example.proyectoZapateria.data.repository.remote.UsuarioRemoteRepository&#10;import com.example.proyectoZapateria.domain.validation.validateProfileEmail&#10;import com.example.proyectoZapateria.domain.validation.validateProfileName&#10;import com.example.proyectoZapateria.domain.validation.validateProfilePhone&#10;import com.example.proyectoZapateria.domain.validation.validateProfileStreet&#10;import com.example.proyectoZapateria.domain.validation.validateProfileHouseNumber&#10;import dagger.hilt.android.lifecycle.HiltViewModel&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.launch&#10;import kotlinx.coroutines.withContext&#10;import okhttp3.MediaType.Companion.toMediaTypeOrNull&#10;import okhttp3.MediaType.Companion.toMediaTypeOrNull&#10;import okhttp3.RequestBody.Companion.asRequestBody&#10;import java.io.File&#10;import javax.inject.Inject&#10;&#10;@HiltViewModel&#10;class ClientePerfilViewModel @Inject constructor(&#10;    private val clienteRemoteRepository: ClienteRemoteRepository,&#10;    private val personaRemoteRepository: PersonaRemoteRepository,&#10;    private val authRemoteRepository: AuthRemoteRepository,&#10;    private val ventasRemoteRepository: VentasRemoteRepository,&#10;    private val usuarioRemoteRepository: UsuarioRemoteRepository,&#10;    private val sessionPreferences: SessionPreferences&#10;) : ViewModel() {&#10;&#10;    private val _uiState = MutableStateFlow(ClientePerfilUiState())&#10;    val uiState: StateFlow&lt;ClientePerfilUiState&gt; = _uiState.asStateFlow()&#10;&#10;    // Estado de edición y campos editables&#10;    private val _isEditing = MutableStateFlow(false)&#10;    val isEditing = _isEditing.asStateFlow()&#10;&#10;    private val _editNombre = MutableStateFlow(&quot;&quot;)&#10;    private val _editApellido = MutableStateFlow(&quot;&quot;)&#10;    private val _editEmail = MutableStateFlow(&quot;&quot;)&#10;    private val _editTelefono = MutableStateFlow(&quot;&quot;)&#10;    private val _editCalle = MutableStateFlow(&quot;&quot;)&#10;    private val _editNumeroPuerta = MutableStateFlow(&quot;&quot;)&#10;&#10;    val editNombre = _editNombre.asStateFlow()&#10;    val editApellido = _editApellido.asStateFlow()&#10;    val editEmail = _editEmail.asStateFlow()&#10;    val editTelefono = _editTelefono.asStateFlow()&#10;    val editCalle = _editCalle.asStateFlow()&#10;    val editNumeroPuerta = _editNumeroPuerta.asStateFlow()&#10;&#10;    private var personaActual: PersonaDTO? = null&#10;&#10;    private val _profileImageUri = MutableStateFlow&lt;Uri?&gt;(null)&#10;    val profileImageUri: StateFlow&lt;Uri?&gt; = _profileImageUri.asStateFlow()&#10;&#10;    data class PhotoLoadTrigger(val idPersona: Long, val timestamp: Long = System.currentTimeMillis())&#10;&#10;    private val _needsPhotoLoad = MutableStateFlow&lt;PhotoLoadTrigger?&gt;(null)&#10;    val needsPhotoLoad: StateFlow&lt;PhotoLoadTrigger?&gt; = _needsPhotoLoad.asStateFlow()&#10;&#10;    init {&#10;        cargarPerfil()&#10;    }&#10;&#10;&#10;    private fun cargarPerfil() {&#10;        viewModelScope.launch {&#10;            try {&#10;                _uiState.value = _uiState.value.copy(isLoading = true, error = null)&#10;&#10;                val currentUser = authRemoteRepository.currentUser.value&#10;                if (currentUser == null) {&#10;                    _uiState.value = _uiState.value.copy(isLoading = false, error = &quot;No hay sesión activa&quot;)&#10;                    return@launch&#10;                }&#10;&#10;                val idPersona = currentUser.idPersona&#10;&#10;                // Obtener datos del cliente desde API remota&#10;                val clienteResult = clienteRemoteRepository.obtenerClientePorId(idPersona)&#10;                val personaResult = personaRemoteRepository.obtenerPersonaPorId(idPersona)&#10;&#10;                if (clienteResult.isSuccess &amp;&amp; personaResult.isSuccess) {&#10;                    val cliente = clienteResult.getOrNull()&#10;                    val persona = personaResult.getOrNull()&#10;&#10;                    if (cliente != null &amp;&amp; persona != null) {&#10;                        // Estadísticas: contar boletas del cliente (via remoto)&#10;                        var total = 0&#10;                        try {&#10;                            val boletasRes = ventasRemoteRepository.obtenerBoletasPorCliente(idPersona)&#10;                            if (boletasRes.isSuccess) {&#10;                                val boletas = boletasRes.getOrNull()&#10;                                total = boletas?.size ?: 0&#10;                            }&#10;                        } catch (e: Exception) {&#10;                            // si falla, mantenemos total = 0&#10;                            Log.w(&quot;ClientePerfilVM&quot;, &quot;No se pudo obtener boletas remotas: ${e.message}&quot;)&#10;                        }&#10;&#10;                        _uiState.value = ClientePerfilUiState(&#10;                            nombre = cliente.nombreCompleto ?: &quot;&quot;,&#10;                            email = cliente.email ?: &quot;&quot;,&#10;                            telefono = cliente.telefono ?: &quot;&quot;,&#10;                            categoria = cliente.categoria ?: &quot;&quot;,&#10;                            calle = persona.calle ?: &quot;&quot;,&#10;                            numeroPuerta = persona.numeroPuerta ?: &quot;&quot;,&#10;                            totalPedidos = total,&#10;                            isLoading = false&#10;                        )&#10;&#10;                        // Poblar campos editables&#10;                        personaActual = persona&#10;                        _editNombre.value = persona.nombre ?: &quot;&quot;&#10;                        _editApellido.value = persona.apellido ?: &quot;&quot;&#10;                        _editEmail.value = persona.email ?: &quot;&quot;&#10;                        _editTelefono.value = persona.telefono ?: &quot;&quot;&#10;                        _editCalle.value = persona.calle ?: &quot;&quot;&#10;                        _editNumeroPuerta.value = persona.numeroPuerta ?: &quot;&quot;&#10;&#10;                        // Marcar que necesita cargar la foto (con timestamp para forzar recarga)&#10;                        _needsPhotoLoad.value = PhotoLoadTrigger(idPersona)&#10;                    } else {&#10;                        _uiState.value = _uiState.value.copy(isLoading = false, error = &quot;No se encontró información del cliente o persona&quot;)&#10;                    }&#10;                } else {&#10;                    _uiState.value = _uiState.value.copy(isLoading = false, error = &quot;Error al obtener datos del cliente&quot;)&#10;                }&#10;            } catch (e: Exception) {&#10;                _uiState.value = _uiState.value.copy(isLoading = false, error = e.message ?: &quot;Error desconocido&quot;)&#10;            }&#10;        }&#10;    }&#10;&#10;    // Comienzo edición&#10;    fun startEdit() {&#10;        _isEditing.value = true&#10;    }&#10;&#10;    fun cancelEdit() {&#10;        // restaurar valores desde personaActual&#10;        personaActual?.let { p -&gt;&#10;            _editNombre.value = p.nombre ?: &quot;&quot;&#10;            _editApellido.value = p.apellido ?: &quot;&quot;&#10;            _editEmail.value = p.email ?: &quot;&quot;&#10;            _editTelefono.value = p.telefono ?: &quot;&quot;&#10;            _editCalle.value = p.calle ?: &quot;&quot;&#10;            _editNumeroPuerta.value = p.numeroPuerta ?: &quot;&quot;&#10;        }&#10;        _isEditing.value = false&#10;    }&#10;&#10;    fun updateEditField(nombre: String? = null, apellido: String? = null, email: String? = null, telefono: String? = null, calle: String? = null, numeroPuerta: String? = null) {&#10;        nombre?.let { _editNombre.value = it }&#10;        apellido?.let { _editApellido.value = it }&#10;        email?.let { _editEmail.value = it }&#10;        telefono?.let { _editTelefono.value = it }&#10;        calle?.let { _editCalle.value = it }&#10;        numeroPuerta?.let { _editNumeroPuerta.value = it }&#10;    }&#10;&#10;    // Guardar cambios en PersonaDTO usando API remota&#10;    fun guardarCambios(onResult: (Boolean, String?) -&gt; Unit) {&#10;        viewModelScope.launch {&#10;            try {&#10;                val persona = personaActual&#10;                if (persona == null) {&#10;                    onResult(false, &quot;No se encontró la persona&quot;)&#10;                    return@launch&#10;                }&#10;&#10;                val emailVal = _editEmail.value.trim()&#10;                val nuevoUsername = if (emailVal.isNotBlank()) emailVal else (persona.username ?: &quot;&quot;)&#10;&#10;                val actualizado = persona.copy(&#10;                    nombre = _editNombre.value.trim(),&#10;                    apellido = _editApellido.value.trim(),&#10;                    email = emailVal.ifBlank { null },&#10;                    telefono = _editTelefono.value.trim().ifBlank { null },&#10;                    calle = _editCalle.value.trim().ifBlank { null },&#10;                    numeroPuerta = _editNumeroPuerta.value.trim().ifBlank { null },&#10;                    username = nuevoUsername&#10;                )&#10;&#10;                // Validaciones: nombre, email, teléfono&#10;                val nombreVal = _editNombre.value.trim()&#10;                val nombreErr = validateProfileName(nombreVal)&#10;                if (nombreErr != null) { onResult(false, nombreErr); return@launch }&#10;&#10;                if (emailVal.isNotBlank()) {&#10;                    val emailErr = validateProfileEmail(emailVal)&#10;                    if (emailErr != null) { onResult(false, emailErr); return@launch }&#10;                    // Validación de email único lo debe hacer el backend&#10;                }&#10;&#10;                val telefonoVal = _editTelefono.value.trim()&#10;                val telErr = validateProfilePhone(telefonoVal)&#10;                if (telErr != null) { onResult(false, telErr); return@launch }&#10;&#10;                // Validar dirección&#10;                val calleVal = _editCalle.value.trim()&#10;                if (calleVal.isNotBlank()) {&#10;                    val calleErr = validateProfileStreet(calleVal)&#10;                    if (calleErr != null) { onResult(false, calleErr); return@launch }&#10;                }&#10;&#10;                val numeroPuertaVal = _editNumeroPuerta.value.trim()&#10;                if (numeroPuertaVal.isNotBlank()) {&#10;                    val numeroPuertaErr = validateProfileHouseNumber(numeroPuertaVal)&#10;                    if (numeroPuertaErr != null) { onResult(false, numeroPuertaErr); return@launch }&#10;                }&#10;&#10;                // Actualizar persona en el API remota&#10;                val res = personaRemoteRepository.actualizarPersona(persona.idPersona ?: 0, actualizado)&#10;                if (res.isSuccess) {&#10;                    // Actualizar sesión si el usuario visible cambió (nombre/email)&#10;                    val current = authRemoteRepository.currentUser.value&#10;                    if (current != null &amp;&amp; current.idPersona == persona.idPersona) {&#10;                        // Obtener usuario actualizado desde API&#10;                        val usuarioActualizadoResult = authRemoteRepository.obtenerUsuarioPorId(persona.idPersona)&#10;                        usuarioActualizadoResult.onSuccess { nuevoUsuario -&gt;&#10;                            authRemoteRepository.setCurrentUser(nuevoUsuario)&#10;                            // Actualizar DataStore/sessionPreferences con el nuevo username si cambió&#10;                            try {&#10;                                sessionPreferences.saveSession(&#10;                                    userId = nuevoUsuario.idPersona,&#10;                                    username = nuevoUsuario.username,&#10;                                    userRole = nuevoUsuario.nombreRol,&#10;                                    userRoleId = nuevoUsuario.idRol&#10;                                )&#10;                            } catch (_: Exception) {&#10;                                // no bloquear la operación por fallo en preferences&#10;                            }&#10;                        }&#10;                    }&#10;                    // refrescar UI local&#10;                    cargarPerfil()&#10;                    _isEditing.value = false&#10;                    onResult(true, null)&#10;                } else {&#10;                    onResult(false, res.exceptionOrNull()?.message ?: &quot;Error al guardar&quot;)&#10;                }&#10;            } catch (e: Exception) {&#10;                onResult(false, e.message)&#10;            }&#10;        }&#10;    }&#10;&#10;    fun onProfileImageSelected(context: Context, file: File) {&#10;        viewModelScope.launch {&#10;            try {&#10;                val currentUser = authRemoteRepository.currentUser.value&#10;                if (currentUser == null) {&#10;                    Log.e(&quot;ClientePerfilVM&quot;, &quot;No hay usuario autenticado&quot;)&#10;                    return@launch&#10;                }&#10;&#10;                _profileImageUri.value = Uri.fromFile(file)&#10;&#10;                // Comprimir la imagen antes de subir (máximo 1024x1024, calidad 80%)&#10;                val compressedFile = withContext(Dispatchers.IO) {&#10;                    com.example.proyectoZapateria.util.ImageCompressor.compressImageFromFile(&#10;                        context, file, maxWidth = 1024, maxHeight = 1024, quality = 80&#10;                    )&#10;                }&#10;&#10;                if (compressedFile == null) {&#10;                    Log.e(&quot;ClientePerfilVM&quot;, &quot;Error al comprimir imagen&quot;)&#10;                    return@launch&#10;                }&#10;&#10;                val requestFile = compressedFile.asRequestBody(&quot;image/*&quot;.toMediaTypeOrNull())&#10;                val fotoPart = okhttp3.MultipartBody.Part.createFormData(&#10;                    &quot;foto&quot;,&#10;                    compressedFile.name,&#10;                    requestFile&#10;                )&#10;&#10;                val result = usuarioRemoteRepository.subirFotoPerfil(currentUser.idPersona, fotoPart)&#10;&#10;                result.onSuccess {&#10;                    // Eliminar archivo comprimido temporal&#10;                    compressedFile.delete()&#10;                    kotlinx.coroutines.delay(500)&#10;                    cargarFotoPerfil(context, currentUser.idPersona)&#10;                }.onFailure { error -&gt;&#10;                    compressedFile.delete()&#10;                    Log.e(&quot;ClientePerfilVM&quot;, &quot;Error al subir foto: ${error.message}&quot;)&#10;                }&#10;            } catch (e: Exception) {&#10;                Log.e(&quot;ClientePerfilVM&quot;, &quot;Error al procesar imagen: ${e.message}&quot;)&#10;            }&#10;        }&#10;    }&#10;&#10;    // Cargar foto de perfil desde el servidor&#10;    fun cargarFotoPerfil(context: Context, idPersona: Long) {&#10;        viewModelScope.launch {&#10;            try {&#10;                val result = usuarioRemoteRepository.obtenerFotoPerfil(idPersona)&#10;                result.onSuccess { fotoBytes -&gt;&#10;                    if (fotoBytes != null &amp;&amp; fotoBytes.isNotEmpty()) {&#10;                        _profileImageUri.value?.let { oldUri -&gt;&#10;                            try {&#10;                                val oldFile = File(oldUri.path ?: &quot;&quot;)&#10;                                if (oldFile.exists()) oldFile.delete()&#10;                            } catch (e: Exception) {&#10;                                // Silenciar error al eliminar archivo anterior&#10;                            }&#10;                        }&#10;&#10;                        val timestamp = System.currentTimeMillis()&#10;                        val tempFile = File(context.cacheDir, &quot;profile_${idPersona}_${timestamp}.jpg&quot;)&#10;                        tempFile.writeBytes(fotoBytes)&#10;                        _profileImageUri.value = Uri.fromFile(tempFile)&#10;                        _uiState.value = _uiState.value.copy(profileImageUri = tempFile.absolutePath)&#10;                    }&#10;                }&#10;            } catch (e: Exception) {&#10;                Log.e(&quot;ClientePerfilVM&quot;, &quot;Error al cargar foto: ${e.message}&quot;)&#10;            }&#10;        }&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>