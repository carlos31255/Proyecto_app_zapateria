<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/proyectoZapateria/data/local/database/AppDatabase.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/proyectoZapateria/data/local/database/AppDatabase.kt" />
              <option name="originalContent" value="package com.example.proyectoZapateria.data.local.database&#10;&#10;import android.content.Context&#10;import android.util.Log&#10;import androidx.room.Database&#10;import androidx.room.Room&#10;import androidx.room.RoomDatabase&#10;import androidx.sqlite.db.SupportSQLiteDatabase&#10;import com.example.proyectoZapateria.data.local.boletaventa.BoletaVentaDao&#10;import com.example.proyectoZapateria.data.local.boletaventa.BoletaVentaEntity&#10;import com.example.proyectoZapateria.data.local.cart.CartDao&#10;import com.example.proyectoZapateria.data.local.cart.CartItemEntity&#10;import com.example.proyectoZapateria.data.local.comuna.ComunaDao&#10;import com.example.proyectoZapateria.data.local.comuna.ComunaEntity&#10;import com.example.proyectoZapateria.data.local.detalleboleta.DetalleBoletaDao&#10;import com.example.proyectoZapateria.data.local.detalleboleta.DetalleBoletaEntity&#10;import com.example.proyectoZapateria.data.local.entrega.EntregaDao&#10;import com.example.proyectoZapateria.data.local.entrega.EntregaEntity&#10;import com.example.proyectoZapateria.data.local.inventario.InventarioDao&#10;import com.example.proyectoZapateria.data.local.inventario.InventarioEntity&#10;import com.example.proyectoZapateria.data.local.marca.MarcaDao&#10;import com.example.proyectoZapateria.data.local.marca.MarcaEntity&#10;import com.example.proyectoZapateria.data.local.modelo.ModeloZapatoDao&#10;import com.example.proyectoZapateria.data.local.modelo.ModeloZapatoEntity&#10;import com.example.proyectoZapateria.data.local.movimientoinventario.MovimientoInventarioDao&#10;import com.example.proyectoZapateria.data.local.movimientoinventario.MovimientoInventarioEntity&#10;import com.example.proyectoZapateria.data.local.region.RegionDao&#10;import com.example.proyectoZapateria.data.local.region.RegionEntity&#10;import com.example.proyectoZapateria.data.local.talla.TallaDao&#10;import com.example.proyectoZapateria.data.local.talla.TallaEntity&#10;import com.example.proyectoZapateria.data.local.tipomovimiento.TipoMovimientoDao&#10;import com.example.proyectoZapateria.data.local.tipomovimiento.TipoMovimientoEntity&#10;import com.example.proyectoZapateria.data.local.transportista.TransportistaDao&#10;import com.example.proyectoZapateria.data.local.transportista.TransportistaEntity&#10;import kotlinx.coroutines.CoroutineScope&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.launch&#10;import kotlinx.coroutines.flow.first&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;&#10;@Database(&#10;    entities = [&#10;        // Catálogos base&#10;        RegionEntity::class,&#10;        ComunaEntity::class,&#10;        MarcaEntity::class,&#10;        TallaEntity::class,&#10;        TipoMovimientoEntity::class,&#10;&#10;        // Entidades principales (solo Transportista - Persona, Usuario, Rol, Cliente ahora son remotos)&#10;        TransportistaEntity::class,&#10;&#10;        // Productos e inventario&#10;        ModeloZapatoEntity::class,&#10;        InventarioEntity::class,&#10;        MovimientoInventarioEntity::class,&#10;&#10;        // Ventas y entregas&#10;        BoletaVentaEntity::class,&#10;        DetalleBoletaEntity::class,&#10;        EntregaEntity::class,&#10;&#10;        // Carrito&#10;        CartItemEntity::class&#10;    ],&#10;    version = 14, // Incrementamos la versión por el cambio de schema&#10;    exportSchema = true&#10;)&#10;abstract class AppDatabase : RoomDatabase() {&#10;&#10;    // === Catálogos base ===&#10;    // Daos que rara vez cambian pero son necesarios&#10;    abstract fun regionDao(): RegionDao&#10;    abstract fun comunaDao(): ComunaDao&#10;    abstract fun tallaDao(): TallaDao&#10;    abstract fun tipoMovimientoDao(): TipoMovimientoDao&#10;&#10;    // === Entidades principales ===&#10;    // PersonaDao, ClienteDao, UsuarioDao y RolDao ahora se manejan con microservicio&#10;    abstract fun transportistaDao(): TransportistaDao&#10;&#10;    // === Productos e inventario ===&#10;    abstract fun marcaDao(): MarcaDao&#10;    abstract fun modeloZapatoDao(): ModeloZapatoDao&#10;    abstract fun inventarioDao(): InventarioDao&#10;    abstract fun movimientoInventarioDao(): MovimientoInventarioDao&#10;&#10;    // === Ventas y entregas ===&#10;    abstract fun boletaVentaDao(): BoletaVentaDao&#10;    abstract fun detalleBoletaDao(): DetalleBoletaDao&#10;    abstract fun entregaDao(): EntregaDao&#10;&#10;    // === Carrito ===&#10;    abstract fun cartDao(): CartDao&#10;&#10;    companion object {&#10;        @Volatile&#10;        private var INSTANCE: AppDatabase? = null&#10;&#10;        // Señal pública que indica si la precarga inicial terminó&#10;        private val _preloadComplete = MutableStateFlow(false)&#10;        val preloadComplete = _preloadComplete.asStateFlow()&#10;&#10;        // Nombre del archivo de base de datos&#10;        private const val DB_NAME = &quot;zapateria.db&quot;&#10;&#10;        // Obtiene la instancia única de la base de datos&#10;        fun getInstance(context: Context): AppDatabase {&#10;            return INSTANCE ?: synchronized(this) {&#10;                // Construimos la DB con callback de precarga&#10;                val instance = Room.databaseBuilder(&#10;                    context.applicationContext,&#10;                    AppDatabase::class.java,&#10;                    DB_NAME&#10;                )&#10;                    // Callback para ejecutar cuando la DB se crea por primera vez&#10;                    .addCallback(object : Callback() {&#10;                        override fun onCreate(db: SupportSQLiteDatabase) {&#10;                            super.onCreate(db)&#10;                            Log.d(&quot;AppDatabase&quot;, &quot;onCreate callback - iniciando precarga de datos&quot;)&#10;                            // Lanzamos una corrutina en IO para insertar datos iniciales&#10;                            CoroutineScope(Dispatchers.IO).launch {&#10;                                try {&#10;                                    Log.d(&quot;AppDatabase&quot;, &quot;Iniciando preloadData...&quot;)&#10;                                    preloadData(getInstance(context))&#10;                                    Log.d(&quot;AppDatabase&quot;, &quot;preloadData completado exitosamente&quot;)&#10;                                } catch (e: Exception) {&#10;                                    Log.e(&quot;AppDatabase&quot;, &quot;Error en preloadData: ${e.message}&quot;, e)&#10;                                } finally {&#10;                                    // Asegurarse de que la señal se marque aunque algo falle&#10;                                    _preloadComplete.value = true&#10;                                    Log.d(&quot;AppDatabase&quot;, &quot;Precarga marcada como completa&quot;)&#10;                                }&#10;                            }&#10;                        }&#10;&#10;                        override fun onOpen(db: SupportSQLiteDatabase) {&#10;                            super.onOpen(db)&#10;                            Log.d(&quot;AppDatabase&quot;, &quot;onOpen callback - base de datos abierta&quot;)&#10;                            // Si la DB ya existe, marcar precarga como completa&#10;                            if (!_preloadComplete.value) {&#10;                                _preloadComplete.value = true&#10;                            }&#10;                        }&#10;                    })&#10;                    // En entorno educativo, si cambias versión sin migraciones, destruye y recrea&#10;                    .fallbackToDestructiveMigration()&#10;                    // Permitir consultas en el hilo principal solo para debugging (eliminar en producción)&#10;                    .allowMainThreadQueries()&#10;                    .build()&#10;&#10;                INSTANCE = instance&#10;                Log.d(&quot;AppDatabase&quot;, &quot;Instancia de base de datos creada&quot;)&#10;                instance&#10;            }&#10;        }&#10;&#10;        // Función para precargar datos iniciales en la base de datos&#10;        // Solo precarga tablas locales: Marcas, Modelos, Tallas e Inventario&#10;        // Las tablas de Persona, Usuario, Rol y Cliente ahora se manejan con microservicios&#10;        private suspend fun preloadData(database: AppDatabase) {&#10;            val marcaDao = database.marcaDao()&#10;            val modeloDao = database.modeloZapatoDao()&#10;            val tallaDao = database.tallaDao()&#10;            val inventarioDao = database.inventarioDao()&#10;&#10;            try {&#10;                // Marca propia de la aplicación&#10;                val appBrandName = &quot;StepStyle&quot;&#10;                val appMarca = marcaDao.getMarcaByNombre(appBrandName)&#10;                val appMarcaId = if (appMarca == null) {&#10;                    val id = marcaDao.insertMarca(&#10;                        MarcaEntity(&#10;                            idMarca = 0,&#10;                            nombreMarca = appBrandName,&#10;                            descripcion = &quot;Marca propia StepStyle&quot;,&#10;                            estado = &quot;activa&quot;&#10;                        )&#10;                    )&#10;                    id.toInt()&#10;                } else {&#10;                    appMarca.idMarca&#10;                }&#10;&#10;                // Precargar modelos para la marca propia&#10;                val modelosApp = listOf(&#10;                    ModeloZapatoEntity(&#10;                        idModelo = 0,&#10;                        idMarca = appMarcaId,&#10;                        nombreModelo = &quot;StepStyle Classic&quot;,&#10;                        descripcion = &quot;Zapatillas clásicas cómodas&quot;,&#10;                        precioUnitario = 39990,&#10;                        imagenUrl = &quot;classic&quot;,&#10;                        estado = &quot;activo&quot;&#10;                    ),&#10;                    ModeloZapatoEntity(&#10;                        idModelo = 0,&#10;                        idMarca = appMarcaId,&#10;                        nombreModelo = &quot;StepStyle Runner&quot;,&#10;                        descripcion = &quot;Runner ligero para entrenamiento&quot;,&#10;                        precioUnitario = 49990,&#10;                        imagenUrl = &quot;runner&quot;,&#10;                        estado = &quot;activo&quot;&#10;                    ),&#10;                    ModeloZapatoEntity(&#10;                        idModelo = 0,&#10;                        idMarca = appMarcaId,&#10;                        nombreModelo = &quot;StepStyle Urban&quot;,&#10;                        descripcion = &quot;Casual urbano con diseño moderno&quot;,&#10;                        precioUnitario = 45990,&#10;                        imagenUrl = &quot;urban&quot;,&#10;                        estado = &quot;activo&quot;&#10;                    ),&#10;                    ModeloZapatoEntity(&#10;                        idModelo = 0,&#10;                        idMarca = appMarcaId,&#10;                        nombreModelo = &quot;StepStyle Kids&quot;,&#10;                        descripcion = &quot;Zapatillas para niños&quot;,&#10;                        precioUnitario = 29990,&#10;                        imagenUrl = &quot;kids&quot;,&#10;                        estado = &quot;activo&quot;&#10;                    )&#10;                )&#10;&#10;                modelosApp.forEach { modelo -&gt;&#10;                    try {&#10;                        val existeModelo = modeloDao.existeModeloEnMarca(appMarcaId, modelo.nombreModelo)&#10;                        if (existeModelo == 0) {&#10;                            modeloDao.insertModelo(modelo)&#10;                            Log.d(&quot;AppDatabase&quot;, &quot;Preload: inserted modelo '${modelo.nombreModelo}' for marcaId=$appMarcaId&quot;)&#10;                        }&#10;                    } catch (_: Exception) {&#10;                        // Ignorar errores de inserción duplicada&#10;                    }&#10;                }&#10;                Log.d(&quot;AppDatabase&quot;, &quot;Preload: marca '$appBrandName' id=$appMarcaId, modelos intentados=${modelosApp.size}&quot;)&#10;&#10;                // Precargar tallas e inventario para los modelos de StepStyle&#10;                val tallasIniciales = listOf(&quot;38&quot;, &quot;39&quot;, &quot;40&quot;, &quot;41&quot;, &quot;42&quot;, &quot;43&quot;)&#10;                val idsTallas = mutableListOf&lt;Int&gt;()&#10;                tallasIniciales.forEach { numero -&gt;&#10;                    val existe = tallaDao.getByNumero(numero)&#10;                    val id = if (existe == null) {&#10;                        tallaDao.insert(TallaEntity(idTalla = 0, numeroTalla = numero)).toInt()&#10;                    } else {&#10;                        existe.idTalla&#10;                    }&#10;                    idsTallas.add(id)&#10;                    Log.d(&quot;AppDatabase&quot;, &quot;Preload: talla '$numero' id=$id&quot;)&#10;                }&#10;&#10;                // Obtener modelos creados para la marca y crear inventario&#10;                val modelosCreados = modeloDao.getModelosByMarca(appMarcaId).first()&#10;                modelosCreados.forEach { modeloCreado -&gt;&#10;                    idsTallas.forEachIndexed { idx, idTalla -&gt;&#10;                        try {&#10;                            val existeInv = inventarioDao.getByModeloYTalla(modeloCreado.idModelo, idTalla)&#10;                            if (existeInv == null) {&#10;                                // Asignar stock inicial variable por talla&#10;                                val stockInicial = when (idx) {&#10;                                    0 -&gt; 5&#10;                                    1 -&gt; 4&#10;                                    2 -&gt; 6&#10;                                    3 -&gt; 3&#10;                                    4 -&gt; 2&#10;                                    else -&gt; 1&#10;                                }&#10;                                val invId = inventarioDao.insert(&#10;                                    InventarioEntity(&#10;                                        idInventario = 0,&#10;                                        idModelo = modeloCreado.idModelo,&#10;                                        idTalla = idTalla,&#10;                                        stockActual = stockInicial&#10;                                    )&#10;                                )&#10;                                Log.d(&quot;AppDatabase&quot;, &quot;Preload: inventario creado id=$invId modelo=${modeloCreado.nombreModelo} tallaId=$idTalla stock=$stockInicial&quot;)&#10;                            }&#10;                        } catch (_: Exception) {&#10;                            // Ignorar errores y continuar&#10;                        }&#10;                    }&#10;                }&#10;&#10;                Log.d(&quot;AppDatabase&quot;, &quot;preloadData completado exitosamente&quot;)&#10;                Log.d(&quot;AppDatabase&quot;, &quot;Precarga marcada como completa&quot;)&#10;            } catch (e: Exception) {&#10;                Log.e(&quot;AppDatabase&quot;, &quot;Error en preloadData: ${e.message}&quot;, e)&#10;                // Asegurarse de que la señal se marque aunque algo falle&#10;                Log.d(&quot;AppDatabase&quot;, &quot;Precarga marcada como completa&quot;)&#10;            } finally {&#10;                _preloadComplete.value = true&#10;            }&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.proyectoZapateria.data.local.database&#10;&#10;import android.content.Context&#10;import android.util.Log&#10;import androidx.room.Database&#10;import androidx.room.Room&#10;import androidx.room.RoomDatabase&#10;import androidx.sqlite.db.SupportSQLiteDatabase&#10;import com.example.proyectoZapateria.data.local.boletaventa.BoletaVentaDao&#10;import com.example.proyectoZapateria.data.local.boletaventa.BoletaVentaEntity&#10;import com.example.proyectoZapateria.data.local.cart.CartDao&#10;import com.example.proyectoZapateria.data.local.cart.CartItemEntity&#10;import com.example.proyectoZapateria.data.local.comuna.ComunaDao&#10;import com.example.proyectoZapateria.data.local.comuna.ComunaEntity&#10;import com.example.proyectoZapateria.data.local.detalleboleta.DetalleBoletaDao&#10;import com.example.proyectoZapateria.data.local.detalleboleta.DetalleBoletaEntity&#10;import com.example.proyectoZapateria.data.local.entrega.EntregaDao&#10;import com.example.proyectoZapateria.data.local.entrega.EntregaEntity&#10;import com.example.proyectoZapateria.data.local.inventario.InventarioDao&#10;import com.example.proyectoZapateria.data.local.inventario.InventarioEntity&#10;import com.example.proyectoZapateria.data.local.marca.MarcaDao&#10;import com.example.proyectoZapateria.data.local.marca.MarcaEntity&#10;import com.example.proyectoZapateria.data.local.modelo.ModeloZapatoDao&#10;import com.example.proyectoZapateria.data.local.modelo.ModeloZapatoEntity&#10;import com.example.proyectoZapateria.data.local.movimientoinventario.MovimientoInventarioDao&#10;import com.example.proyectoZapateria.data.local.movimientoinventario.MovimientoInventarioEntity&#10;import com.example.proyectoZapateria.data.local.region.RegionDao&#10;import com.example.proyectoZapateria.data.local.region.RegionEntity&#10;import com.example.proyectoZapateria.data.local.talla.TallaDao&#10;import com.example.proyectoZapateria.data.local.talla.TallaEntity&#10;import com.example.proyectoZapateria.data.local.tipomovimiento.TipoMovimientoDao&#10;import com.example.proyectoZapateria.data.local.tipomovimiento.TipoMovimientoEntity&#10;import com.example.proyectoZapateria.data.local.transportista.TransportistaDao&#10;import com.example.proyectoZapateria.data.local.transportista.TransportistaEntity&#10;import kotlinx.coroutines.CoroutineScope&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.launch&#10;import kotlinx.coroutines.flow.first&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;&#10;@Database(&#10;    entities = [&#10;        // Catálogos base&#10;        RegionEntity::class,&#10;        ComunaEntity::class,&#10;        MarcaEntity::class,&#10;        TallaEntity::class,&#10;        TipoMovimientoEntity::class,&#10;&#10;        // Entidades principales (solo Transportista - Persona, Usuario, Rol, Cliente ahora son remotos)&#10;        TransportistaEntity::class,&#10;&#10;        // Productos e inventario&#10;        ModeloZapatoEntity::class,&#10;        InventarioEntity::class,&#10;        MovimientoInventarioEntity::class,&#10;&#10;        // Ventas y entregas&#10;        BoletaVentaEntity::class,&#10;        DetalleBoletaEntity::class,&#10;        EntregaEntity::class,&#10;&#10;        // Carrito&#10;        CartItemEntity::class&#10;    ],&#10;    version = 14, // Incrementamos la versión por el cambio de schema&#10;    exportSchema = true&#10;)&#10;abstract class AppDatabase : RoomDatabase() {&#10;&#10;    // === Catálogos base ===&#10;    // Daos que rara vez cambian pero son necesarios&#10;    abstract fun regionDao(): RegionDao&#10;    abstract fun comunaDao(): ComunaDao&#10;    abstract fun tallaDao(): TallaDao&#10;    abstract fun tipoMovimientoDao(): TipoMovimientoDao&#10;&#10;    // === Entidades principales ===&#10;    // PersonaDao, ClienteDao, UsuarioDao y RolDao ahora se manejan con microservicio&#10;    abstract fun transportistaDao(): TransportistaDao&#10;&#10;    // === Productos e inventario ===&#10;    abstract fun marcaDao(): MarcaDao&#10;    abstract fun modeloZapatoDao(): ModeloZapatoDao&#10;    abstract fun inventarioDao(): InventarioDao&#10;    abstract fun movimientoInventarioDao(): MovimientoInventarioDao&#10;&#10;    // === Ventas y entregas ===&#10;    abstract fun boletaVentaDao(): BoletaVentaDao&#10;    abstract fun detalleBoletaDao(): DetalleBoletaDao&#10;    abstract fun entregaDao(): EntregaDao&#10;&#10;    // === Carrito ===&#10;    abstract fun cartDao(): CartDao&#10;&#10;    companion object {&#10;        @Volatile&#10;        private var INSTANCE: AppDatabase? = null&#10;&#10;        // Señal pública que indica si la precarga inicial terminó&#10;        private val _preloadComplete = MutableStateFlow(false)&#10;        val preloadComplete = _preloadComplete.asStateFlow()&#10;&#10;        // Nombre del archivo de base de datos&#10;        private const val DB_NAME = &quot;zapateria.db&quot;&#10;&#10;        // Obtiene la instancia única de la base de datos&#10;        fun getInstance(context: Context): AppDatabase {&#10;            return INSTANCE ?: synchronized(this) {&#10;                // Construimos la DB con callback de precarga&#10;                val instance = Room.databaseBuilder(&#10;                    context.applicationContext,&#10;                    AppDatabase::class.java,&#10;                    DB_NAME&#10;                )&#10;                    // Callback para ejecutar cuando la DB se crea por primera vez&#10;                    .addCallback(object : Callback() {&#10;                        override fun onCreate(db: SupportSQLiteDatabase) {&#10;                            super.onCreate(db)&#10;                            Log.d(&quot;AppDatabase&quot;, &quot;onCreate callback - iniciando precarga de datos&quot;)&#10;                            // Lanzamos una corrutina en IO para insertar datos iniciales&#10;                            CoroutineScope(Dispatchers.IO).launch {&#10;                                try {&#10;                                    Log.d(&quot;AppDatabase&quot;, &quot;Iniciando preloadData...&quot;)&#10;                                    preloadData(getInstance(context))&#10;                                    Log.d(&quot;AppDatabase&quot;, &quot;preloadData completado exitosamente&quot;)&#10;                                } catch (e: Exception) {&#10;                                    Log.e(&quot;AppDatabase&quot;, &quot;Error en preloadData: ${e.message}&quot;, e)&#10;                                } finally {&#10;                                    // Asegurarse de que la señal se marque aunque algo falle&#10;                                    _preloadComplete.value = true&#10;                                    Log.d(&quot;AppDatabase&quot;, &quot;Precarga marcada como completa&quot;)&#10;                                }&#10;                            }&#10;                        }&#10;&#10;                        override fun onOpen(db: SupportSQLiteDatabase) {&#10;                            super.onOpen(db)&#10;                            Log.d(&quot;AppDatabase&quot;, &quot;onOpen callback - base de datos abierta&quot;)&#10;                            // Si la DB ya existe, marcar precarga como completa&#10;                            if (!_preloadComplete.value) {&#10;                                _preloadComplete.value = true&#10;                            }&#10;                        }&#10;                    })&#10;                    // En entorno educativo, si cambias versión sin migraciones, destruye y recrea&#10;                    .fallbackToDestructiveMigration()&#10;                    // Permitir consultas en el hilo principal solo para debugging (eliminar en producción)&#10;                    .allowMainThreadQueries()&#10;                    .build()&#10;&#10;                INSTANCE = instance&#10;                Log.d(&quot;AppDatabase&quot;, &quot;Instancia de base de datos creada&quot;)&#10;                instance&#10;            }&#10;        }&#10;&#10;        // Función para precargar datos iniciales en la base de datos&#10;        // Solo precarga tablas locales: Marcas, Modelos, Tallas e Inventario&#10;        // Las tablas de Persona, Usuario, Rol y Cliente ahora se manejan con microservicios&#10;        private suspend fun preloadData(database: AppDatabase) {&#10;            val marcaDao = database.marcaDao()&#10;            val modeloDao = database.modeloZapatoDao()&#10;            val tallaDao = database.tallaDao()&#10;            val inventarioDao = database.inventarioDao()&#10;&#10;            try {&#10;                // Marca propia de la aplicación&#10;                val appBrandName = &quot;StepStyle&quot;&#10;                val appMarca = marcaDao.getMarcaByNombre(appBrandName)&#10;                val appMarcaId = if (appMarca == null) {&#10;                    val id = marcaDao.insertMarca(&#10;                        MarcaEntity(&#10;                            idMarca = 0,&#10;                            nombreMarca = appBrandName,&#10;                            descripcion = &quot;Marca propia StepStyle&quot;,&#10;                            estado = &quot;activa&quot;&#10;                        )&#10;                    )&#10;                    id.toInt()&#10;                } else {&#10;                    appMarca.idMarca&#10;                }&#10;&#10;                // Precargar modelos para la marca propia&#10;                val modelosApp = listOf(&#10;                    ModeloZapatoEntity(&#10;                        idModelo = 0,&#10;                        idMarca = appMarcaId,&#10;                        nombreModelo = &quot;StepStyle Classic&quot;,&#10;                        descripcion = &quot;Zapatillas clásicas cómodas&quot;,&#10;                        precioUnitario = 39990,&#10;                        imagenUrl = &quot;classic&quot;,&#10;                        estado = &quot;activo&quot;&#10;                    ),&#10;                    ModeloZapatoEntity(&#10;                        idModelo = 0,&#10;                        idMarca = appMarcaId,&#10;                        nombreModelo = &quot;StepStyle Runner&quot;,&#10;                        descripcion = &quot;Runner ligero para entrenamiento&quot;,&#10;                        precioUnitario = 49990,&#10;                        imagenUrl = &quot;runner&quot;,&#10;                        estado = &quot;activo&quot;&#10;                    ),&#10;                    ModeloZapatoEntity(&#10;                        idModelo = 0,&#10;                        idMarca = appMarcaId,&#10;                        nombreModelo = &quot;StepStyle Urban&quot;,&#10;                        descripcion = &quot;Casual urbano con diseño moderno&quot;,&#10;                        precioUnitario = 45990,&#10;                        imagenUrl = &quot;urban&quot;,&#10;                        estado = &quot;activo&quot;&#10;                    ),&#10;                    ModeloZapatoEntity(&#10;                        idModelo = 0,&#10;                        idMarca = appMarcaId,&#10;                        nombreModelo = &quot;StepStyle Kids&quot;,&#10;                        descripcion = &quot;Zapatillas para niños&quot;,&#10;                        precioUnitario = 29990,&#10;                        imagenUrl = &quot;kids&quot;,&#10;                        estado = &quot;activo&quot;&#10;                    )&#10;                )&#10;&#10;                modelosApp.forEach { modelo -&gt;&#10;                    try {&#10;                        val existeModelo = modeloDao.existeModeloEnMarca(appMarcaId, modelo.nombreModelo)&#10;                        if (existeModelo == 0) {&#10;                            modeloDao.insertModelo(modelo)&#10;                            Log.d(&quot;AppDatabase&quot;, &quot;Preload: inserted modelo '${modelo.nombreModelo}' for marcaId=$appMarcaId&quot;)&#10;                        }&#10;                    } catch (_: Exception) {&#10;                        // Ignorar errores de inserción duplicada&#10;                    }&#10;                }&#10;                Log.d(&quot;AppDatabase&quot;, &quot;Preload: marca '$appBrandName' id=$appMarcaId, modelos intentados=${modelosApp.size}&quot;)&#10;&#10;                // Precargar tallas e inventario para los modelos de StepStyle&#10;                val tallasIniciales = listOf(&quot;38&quot;, &quot;39&quot;, &quot;40&quot;, &quot;41&quot;, &quot;42&quot;, &quot;43&quot;)&#10;                val idsTallas = mutableListOf&lt;Int&gt;()&#10;                tallasIniciales.forEach { numero -&gt;&#10;                    val existe = tallaDao.getByNumero(numero)&#10;                    val id = if (existe == null) {&#10;                        tallaDao.insert(TallaEntity(idTalla = 0, numeroTalla = numero)).toInt()&#10;                    } else {&#10;                        existe.idTalla&#10;                    }&#10;                    idsTallas.add(id)&#10;                    Log.d(&quot;AppDatabase&quot;, &quot;Preload: talla '$numero' id=$id&quot;)&#10;                }&#10;&#10;                // Obtener modelos creados para la marca y crear inventario&#10;                val modelosCreados = modeloDao.getModelosByMarca(appMarcaId).first()&#10;                modelosCreados.forEach { modeloCreado -&gt;&#10;                    idsTallas.forEachIndexed { idx, idTalla -&gt;&#10;                        try {&#10;                            val existeInv = inventarioDao.getByModeloYTalla(modeloCreado.idModelo, idTalla)&#10;                            if (existeInv == null) {&#10;                                // Asignar stock inicial variable por talla&#10;                                val stockInicial = when (idx) {&#10;                                    0 -&gt; 5&#10;                                    1 -&gt; 4&#10;                                    2 -&gt; 6&#10;                                    3 -&gt; 3&#10;                                    4 -&gt; 2&#10;                                    else -&gt; 1&#10;                                }&#10;                                val invId = inventarioDao.insert(&#10;                                    InventarioEntity(&#10;                                        idInventario = 0,&#10;                                        idModelo = modeloCreado.idModelo,&#10;                                        idTalla = idTalla,&#10;                                        stockActual = stockInicial&#10;                                    )&#10;                                )&#10;                                Log.d(&quot;AppDatabase&quot;, &quot;Preload: inventario creado id=$invId modelo=${modeloCreado.nombreModelo} tallaId=$idTalla stock=$stockInicial&quot;)&#10;                            }&#10;                        } catch (_: Exception) {&#10;                            // Ignorar errores y continuar&#10;                        }&#10;                    }&#10;                }&#10;&#10;                Log.d(&quot;AppDatabase&quot;, &quot;preloadData completado exitosamente&quot;)&#10;                Log.d(&quot;AppDatabase&quot;, &quot;Precarga marcada como completa&quot;)&#10;            } catch (e: Exception) {&#10;                Log.e(&quot;AppDatabase&quot;, &quot;Error en preloadData: ${e.message}&quot;, e)&#10;                // Asegurarse de que la señal se marque aunque algo falle&#10;                Log.d(&quot;AppDatabase&quot;, &quot;Precarga marcada como completa&quot;)&#10;            } finally {&#10;                _preloadComplete.value = true&#10;            }&#10;        }&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>