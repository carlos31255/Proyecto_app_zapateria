<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/proyectoZapateria/data/local/region/RegionEntity.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/proyectoZapateria/data/local/region/RegionEntity.kt" />
              <option name="originalContent" value="package com.example.proyectoZapateria.data.local.region&#10;&#10;import androidx.room.ColumnInfo&#10;import androidx.room.Entity&#10;import androidx.room.Index&#10;import androidx.room.PrimaryKey&#10;&#10;/**&#10; * Nota: Esta entidad está marcada como obsoleta.&#10; * La geografía (regiones/ciudades/comunas) ahora se obtiene desde el microservicio remoto&#10; * y las tablas locales se eliminaron del esquema de Room en `AppDatabase`.&#10; * Conservamos la clase por compatibilidad temporal; puede ser eliminada en una limpieza futura.&#10; */&#10;@Deprecated(&quot;Reemplazado por geografía remota - mantener temporalmente para compatibilidad&quot;)&#10;@Suppress(&quot;unused&quot;)&#10;@Entity(&#10;    tableName = &quot;region&quot;,&#10;    indices = [Index(value = [&quot;nombre_region&quot;], unique = true)]&#10;)&#10;data class RegionEntity(&#10;    @PrimaryKey(autoGenerate = true)&#10;    @ColumnInfo(name = &quot;id_region&quot;)&#10;    val idRegion: Int = 0,&#10;&#10;    @ColumnInfo(name = &quot;nombre_region&quot;)&#10;    val nombreRegion: String,&#10;&#10;    val abreviatura: String?&#10;)" />
              <option name="updatedContent" value="package com.example.proyectoZapateria.data.local.region&#10;&#10;import androidx.room.ColumnInfo&#10;import androidx.room.Entity&#10;import androidx.room.Index&#10;import androidx.room.PrimaryKey&#10;&#10;/**&#10; * Nota: Esta entidad está marcada como obsoleta.&#10; * La geografía (regiones/ciudades/comunas) ahora se obtiene desde el microservicio remoto&#10; * y las tablas locales se eliminaron del esquema de Room en `AppDatabase`.&#10; * Conservamos la clase por compatibilidad temporal; puede ser eliminada en una limpieza futura.&#10; */&#10;@Deprecated(&quot;Reemplazado por geografía remota - mantener temporalmente para compatibilidad&quot;)&#10;@Suppress(&quot;unused&quot;)&#10;@Entity(&#10;    tableName = &quot;region&quot;,&#10;    indices = [Index(value = [&quot;nombre_region&quot;], unique = true)]&#10;)&#10;data class RegionEntity(&#10;    @PrimaryKey(autoGenerate = true)&#10;    @ColumnInfo(name = &quot;id_region&quot;)&#10;    val idRegion: Int = 0,&#10;&#10;    @ColumnInfo(name = &quot;nombre_region&quot;)&#10;    val nombreRegion: String,&#10;&#10;    val abreviatura: String?&#10;)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/proyectoZapateria/data/repository/remote/InventarioRemoteRepository.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/proyectoZapateria/data/repository/remote/InventarioRemoteRepository.kt" />
              <option name="originalContent" value="package com.example.proyectoZapateria.data.repository.remote&#10;&#10;import com.example.proyectoZapateria.data.remote.inventario.InventarioApiService&#10;import com.example.proyectoZapateria.data.remote.inventario.ProductoApiService&#10;import com.example.proyectoZapateria.data.remote.inventario.dto.InventarioDTO&#10;import com.example.proyectoZapateria.data.remote.inventario.dto.MarcaDTO&#10;import com.example.proyectoZapateria.data.remote.inventario.dto.ProductoDTO&#10;import com.example.proyectoZapateria.data.remote.inventario.dto.TallaDTO&#10;import okhttp3.MultipartBody&#10;import okhttp3.RequestBody&#10;import javax.inject.Inject&#10;import javax.inject.Singleton&#10;import retrofit2.Response&#10;&#10;@Singleton&#10;class InventarioRemoteRepository @Inject constructor(&#10;    private val inventarioApi: InventarioApiService,&#10;    private val productoApi: ProductoApiService&#10;) {&#10;&#10;    // ==========================================&#10;    // Lógica de CATÁLOGO&#10;    // ==========================================&#10;&#10;    suspend fun getMarcas(): Result&lt;List&lt;MarcaDTO&gt;&gt; = safeApiCall { productoApi.obtenerTodasLasMarcas() }&#10;&#10;    suspend fun getMarcaById(id: Long): Result&lt;MarcaDTO&gt; = safeApiCall { productoApi.obtenerMarcaPorId(id) }&#10;&#10;    suspend fun getTallas(): Result&lt;List&lt;TallaDTO&gt;&gt; = safeApiCall { productoApi.obtenerTodasLasTallas() }&#10;&#10;    suspend fun getModelos(): Result&lt;List&lt;ProductoDTO&gt;&gt; = safeApiCall { productoApi.obtenerTodosLosProductos() }&#10;&#10;    suspend fun getModeloById(id: Long): Result&lt;ProductoDTO&gt; = safeApiCall { productoApi.obtenerProductoPorId(id) }&#10;&#10;    suspend fun getModelosByMarca(marcaId: Long): Result&lt;List&lt;ProductoDTO&gt;&gt; = safeApiCall { productoApi.obtenerProductosPorMarca(marcaId) }&#10;&#10;    suspend fun searchModelos(query: String): Result&lt;List&lt;ProductoDTO&gt;&gt; = safeApiCall { productoApi.buscarProductos(query) }&#10;&#10;    suspend fun crearModelo(producto: ProductoDTO) = safeApiCall { productoApi.crearProducto(producto) }&#10;&#10;    suspend fun crearModeloConImagen(productoJson: RequestBody, imagen: MultipartBody.Part?) = safeApiCall { productoApi.crearProductoMultipart(productoJson, imagen) }&#10;&#10;    suspend fun actualizarModelo(id: Long, producto: ProductoDTO) = safeApiCall { productoApi.actualizarProducto(id, producto) }&#10;&#10;    suspend fun eliminarModelo(id: Long) = safeApiCall { productoApi.eliminarProducto(id) }&#10;&#10;    // ==========================================&#10;    // Lógica de STOCK&#10;    // ==========================================&#10;&#10;    // Probar varias rutas sin prefijo /api hasta encontrar una que funcione.&#10;    suspend fun getInventarioPorProducto(productoId: Long): Result&lt;List&lt;InventarioDTO&gt;&gt; {&#10;        // Intentar la ruta principal sin prefijo&#10;        val tryNoApi = safeApiCall { inventarioApi.obtenerInventarioPorModelo(productoId) }&#10;        if (tryNoApi.isSuccess) return tryNoApi&#10;        // Intentar la ruta alternativa sin prefijo (/inventario/modelo/{id})&#10;        val tryAltNoApi = safeApiCall { inventarioApi.obtenerInventarioPorModeloAlt_NoApi(productoId) }&#10;        if (tryAltNoApi.isSuccess) return tryAltNoApi&#10;        // Intentar query general sin prefijo&#10;        return safeApiCall { inventarioApi.obtenerInventarioPorQuery(productoId) }&#10;    }&#10;&#10;    suspend fun getInventarioPorModelo(modeloId: Long) = safeApiCall { inventarioApi.obtenerInventarioPorModelo(modeloId) }&#10;    // Usar la variante sin prefijo: /inventario/modelo/{modeloId}&#10;    suspend fun getInventarioPorModeloAlt(modeloId: Long) = safeApiCall { inventarioApi.obtenerInventarioPorModeloAlt_NoApi(modeloId) }&#10;    suspend fun getInventarioPorQuery(modeloId: Long) = safeApiCall { inventarioApi.obtenerInventarioPorQuery(modeloId) }&#10;&#10;    suspend fun getInventarioById(id: Long): Result&lt;InventarioDTO&gt; {&#10;        // Usar la ruta sin prefijo únicamente&#10;        return safeApiCall { inventarioApi.obtenerInventarioPorId(id) }&#10;    }&#10;&#10;    suspend fun crearInventario(dto: InventarioDTO) = safeApiCall { inventarioApi.crearInventario(dto) }&#10;&#10;    suspend fun actualizarInventario(id: Long, dto: InventarioDTO) = safeApiCall { inventarioApi.actualizarInventario(id, dto) }&#10;&#10;    suspend fun eliminarStock(id: Long) = safeApiCall { inventarioApi.eliminarInventario(id) }&#10;&#10;    // --- Helper ---&#10;    private suspend fun &lt;T&gt; safeApiCall(call: suspend () -&gt; Response&lt;T&gt;): Result&lt;T&gt; {&#10;        return try {&#10;            val response = call()&#10;            if (response.isSuccessful &amp;&amp; response.body() != null) {&#10;                Result.success(response.body()!!)&#10;            } else {&#10;                if (response.isSuccessful &amp;&amp; response.code() == 204) {&#10;                    @Suppress(&quot;UNCHECKED_CAST&quot;)&#10;                    return Result.success(true as T)&#10;                }&#10;                val errorBody = try { response.errorBody()?.string() } catch (_: Exception) { null }&#10;                val code = response.code()&#10;                val msg = response.message()&#10;                Result.failure(Exception(&quot;Error &quot; + code + &quot;: &quot; + msg + &quot; - body=&quot; + (errorBody ?: &quot;&lt;empty&gt;&quot;)))&#10;            }&#10;        } catch (e: Exception) {&#10;            Result.failure(e)&#10;        }&#10;    }&#10;&#10;    suspend fun getTallasLogged(): Result&lt;List&lt;TallaDTO&gt;&gt; {&#10;        return getTallas()&#10;    }&#10;&#10;    suspend fun getInventarioPorModeloLogged(modeloId: Long): Result&lt;List&lt;InventarioDTO&gt;&gt; = run {&#10;        val attempts = listOf&lt;suspend () -&gt; Result&lt;List&lt;InventarioDTO&gt;&gt;&gt;(&#10;            { getInventarioPorModelo(modeloId) },&#10;            { getInventarioPorModeloAlt(modeloId) },&#10;            { getInventarioPorQuery(modeloId) },&#10;            { getInventarioPorProducto(modeloId) }&#10;        )&#10;&#10;        var lastFailure: Result&lt;List&lt;InventarioDTO&gt;&gt;? = null&#10;        for (attempt in attempts) {&#10;            try {&#10;                val res = attempt()&#10;                if (res.isSuccess) {&#10;                    val body = res.getOrNull()&#10;                    if (body is Collection&lt;*&gt;) {&#10;                        if (body.isNotEmpty()) {&#10;                            return@run res&#10;                        } else {&#10;                            lastFailure = res&#10;                        }&#10;                    } else {&#10;                        return@run res&#10;                    }&#10;                } else {&#10;                    lastFailure = res&#10;                }&#10;            } catch (e: Exception) {&#10;                lastFailure = Result.failure(e)&#10;            }&#10;        }&#10;&#10;        lastFailure ?: Result.failure(Exception(&quot;No se pudo ejecutar llamadas&quot;))&#10;    }&#10;&#10;    suspend fun obtenerImagenProducto(id: Long): Result&lt;ByteArray?&gt; {&#10;        return try {&#10;            val response = productoApi.obtenerImagenProducto(id)&#10;            if (response.isSuccessful &amp;&amp; response.body() != null) {&#10;                val body = response.body()!!&#10;                try {&#10;                    val bytes = body.bytes()&#10;                    Result.success(bytes)&#10;                } catch (e: Exception) {&#10;                    Result.failure(Exception(&quot;Error leyendo bytes de la imagen: ${e.message}&quot;))&#10;                }&#10;            } else {&#10;                // si no hay imagen o error 404, retornar success con null para indicar ausencia&#10;                if (response.code() == 404 || response.code() == 204) {&#10;                    Result.success(null)&#10;                } else {&#10;                    val err = try { response.errorBody()?.string() } catch (_: Exception) { null }&#10;                    Result.failure(Exception(&quot;Error ${response.code()}: ${response.message()} - body=${err ?: &quot;&lt;empty&gt;&quot;}&quot;))&#10;                }&#10;            }&#10;        } catch (e: Exception) {&#10;            Result.failure(e)&#10;        }&#10;    }&#10;&#10;    suspend fun getTallasPorProducto(productoId: Long): Result&lt;List&lt;TallaDTO&gt;&gt; {&#10;        val specific = safeApiCall { productoApi.obtenerTallasPorProducto(productoId) }&#10;        if (specific.isSuccess) {&#10;            val list = specific.getOrNull() ?: emptyList()&#10;            if (list.isNotEmpty()) {&#10;                return Result.success(list)&#10;            }&#10;        }&#10;&#10;        val global = safeApiCall { productoApi.obtenerTodasLasTallas() }&#10;        if (global.isSuccess) {&#10;            return global&#10;        }&#10;        return specific.takeIf { it.isFailure } ?: global&#10;    }&#10;&#10;    suspend fun getProductoById(id: Long): Result&lt;ProductoDTO&gt; {&#10;        return safeApiCall {&#10;            productoApi.obtenerProductoPorId(id)&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.proyectoZapateria.data.repository.remote&#10;&#10;import com.example.proyectoZapateria.data.remote.inventario.InventarioApiService&#10;import com.example.proyectoZapateria.data.remote.inventario.ProductoApiService&#10;import com.example.proyectoZapateria.data.remote.inventario.dto.InventarioDTO&#10;import com.example.proyectoZapateria.data.remote.inventario.dto.MarcaDTO&#10;import com.example.proyectoZapateria.data.remote.inventario.dto.ProductoDTO&#10;import com.example.proyectoZapateria.data.remote.inventario.dto.TallaDTO&#10;import okhttp3.MultipartBody&#10;import okhttp3.RequestBody&#10;import javax.inject.Inject&#10;import javax.inject.Singleton&#10;import retrofit2.Response&#10;&#10;@Singleton&#10;class InventarioRemoteRepository @Inject constructor(&#10;    private val inventarioApi: InventarioApiService,&#10;    private val productoApi: ProductoApiService&#10;) {&#10;&#10;    // ==========================================&#10;    // Lógica de CATÁLOGO&#10;    // ==========================================&#10;&#10;    suspend fun getMarcas(): Result&lt;List&lt;MarcaDTO&gt;&gt; = safeApiCall { productoApi.obtenerTodasLasMarcas() }&#10;&#10;    suspend fun getMarcaById(id: Long): Result&lt;MarcaDTO&gt; = safeApiCall { productoApi.obtenerMarcaPorId(id) }&#10;&#10;    suspend fun getTallas(): Result&lt;List&lt;TallaDTO&gt;&gt; = safeApiCall { productoApi.obtenerTodasLasTallas() }&#10;&#10;    suspend fun getModelos(): Result&lt;List&lt;ProductoDTO&gt;&gt; = safeApiCall { productoApi.obtenerTodosLosProductos() }&#10;&#10;    suspend fun getModeloById(id: Long): Result&lt;ProductoDTO&gt; = safeApiCall { productoApi.obtenerProductoPorId(id) }&#10;&#10;    suspend fun getModelosByMarca(marcaId: Long): Result&lt;List&lt;ProductoDTO&gt;&gt; = safeApiCall { productoApi.obtenerProductosPorMarca(marcaId) }&#10;&#10;    suspend fun searchModelos(query: String): Result&lt;List&lt;ProductoDTO&gt;&gt; = safeApiCall { productoApi.buscarProductos(query) }&#10;&#10;    suspend fun crearModelo(producto: ProductoDTO) = safeApiCall { productoApi.crearProducto(producto) }&#10;&#10;    suspend fun crearModeloConImagen(productoJson: RequestBody, imagen: MultipartBody.Part?) = safeApiCall { productoApi.crearProductoMultipart(productoJson, imagen) }&#10;&#10;    suspend fun actualizarModelo(id: Long, producto: ProductoDTO) = safeApiCall { productoApi.actualizarProducto(id, producto) }&#10;&#10;    suspend fun actualizarModeloConImagen(id: Long, productoJson: RequestBody, imagen: MultipartBody.Part?) = safeApiCall { productoApi.actualizarProductoConImagen(id, productoJson, imagen) }&#10;&#10;    suspend fun eliminarModelo(id: Long) = safeApiCall { productoApi.eliminarProducto(id) }&#10;&#10;    // ==========================================&#10;    // Lógica de STOCK&#10;    // ==========================================&#10;&#10;    // Probar varias rutas sin prefijo /api hasta encontrar una que funcione.&#10;    suspend fun getInventarioPorProducto(productoId: Long): Result&lt;List&lt;InventarioDTO&gt;&gt; {&#10;        // Intentar la ruta principal sin prefijo&#10;        val tryNoApi = safeApiCall { inventarioApi.obtenerInventarioPorModelo(productoId) }&#10;        if (tryNoApi.isSuccess) return tryNoApi&#10;        // Intentar la ruta alternativa sin prefijo (/inventario/modelo/{id})&#10;        val tryAltNoApi = safeApiCall { inventarioApi.obtenerInventarioPorModeloAlt_NoApi(productoId) }&#10;        if (tryAltNoApi.isSuccess) return tryAltNoApi&#10;        // Intentar query general sin prefijo&#10;        return safeApiCall { inventarioApi.obtenerInventarioPorQuery(productoId) }&#10;    }&#10;&#10;    suspend fun getInventarioPorModelo(modeloId: Long) = safeApiCall { inventarioApi.obtenerInventarioPorModelo(modeloId) }&#10;    // Usar la variante sin prefijo: /inventario/modelo/{modeloId}&#10;    suspend fun getInventarioPorModeloAlt(modeloId: Long) = safeApiCall { inventarioApi.obtenerInventarioPorModeloAlt_NoApi(modeloId) }&#10;    suspend fun getInventarioPorQuery(modeloId: Long) = safeApiCall { inventarioApi.obtenerInventarioPorQuery(modeloId) }&#10;&#10;    suspend fun getInventarioById(id: Long): Result&lt;InventarioDTO&gt; {&#10;        // Usar la ruta sin prefijo únicamente&#10;        return safeApiCall { inventarioApi.obtenerInventarioPorId(id) }&#10;    }&#10;&#10;    suspend fun crearInventario(dto: InventarioDTO) = safeApiCall { inventarioApi.crearInventario(dto) }&#10;&#10;    suspend fun actualizarInventario(id: Long, dto: InventarioDTO) = safeApiCall { inventarioApi.actualizarInventario(id, dto) }&#10;&#10;    suspend fun eliminarStock(id: Long) = safeApiCall { inventarioApi.eliminarInventario(id) }&#10;&#10;    // --- Helper ---&#10;    private suspend fun &lt;T&gt; safeApiCall(call: suspend () -&gt; Response&lt;T&gt;): Result&lt;T&gt; {&#10;        return try {&#10;            val response = call()&#10;            if (response.isSuccessful &amp;&amp; response.body() != null) {&#10;                Result.success(response.body()!!)&#10;            } else {&#10;                if (response.isSuccessful &amp;&amp; response.code() == 204) {&#10;                    @Suppress(&quot;UNCHECKED_CAST&quot;)&#10;                    return Result.success(true as T)&#10;                }&#10;                val errorBody = try { response.errorBody()?.string() } catch (_: Exception) { null }&#10;                val code = response.code()&#10;                val msg = response.message()&#10;                Result.failure(Exception(&quot;Error &quot; + code + &quot;: &quot; + msg + &quot; - body=&quot; + (errorBody ?: &quot;&lt;empty&gt;&quot;)))&#10;            }&#10;        } catch (e: Exception) {&#10;            Result.failure(e)&#10;        }&#10;    }&#10;&#10;    suspend fun getTallasLogged(): Result&lt;List&lt;TallaDTO&gt;&gt; {&#10;        return getTallas()&#10;    }&#10;&#10;    suspend fun getInventarioPorModeloLogged(modeloId: Long): Result&lt;List&lt;InventarioDTO&gt;&gt; = run {&#10;        val attempts = listOf&lt;suspend () -&gt; Result&lt;List&lt;InventarioDTO&gt;&gt;&gt;(&#10;            { getInventarioPorModelo(modeloId) },&#10;            { getInventarioPorModeloAlt(modeloId) },&#10;            { getInventarioPorQuery(modeloId) },&#10;            { getInventarioPorProducto(modeloId) }&#10;        )&#10;&#10;        var lastFailure: Result&lt;List&lt;InventarioDTO&gt;&gt;? = null&#10;        for (attempt in attempts) {&#10;            try {&#10;                val res = attempt()&#10;                if (res.isSuccess) {&#10;                    val body = res.getOrNull()&#10;                    if (body is Collection&lt;*&gt;) {&#10;                        if (body.isNotEmpty()) {&#10;                            return@run res&#10;                        } else {&#10;                            lastFailure = res&#10;                        }&#10;                    } else {&#10;                        return@run res&#10;                    }&#10;                } else {&#10;                    lastFailure = res&#10;                }&#10;            } catch (e: Exception) {&#10;                lastFailure = Result.failure(e)&#10;            }&#10;        }&#10;&#10;        lastFailure ?: Result.failure(Exception(&quot;No se pudo ejecutar llamadas&quot;))&#10;    }&#10;&#10;    suspend fun obtenerImagenProducto(id: Long): Result&lt;ByteArray?&gt; {&#10;        return try {&#10;            val response = productoApi.obtenerImagenProducto(id)&#10;            if (response.isSuccessful &amp;&amp; response.body() != null) {&#10;                val body = response.body()!!&#10;                try {&#10;                    val bytes = body.bytes()&#10;                    Result.success(bytes)&#10;                } catch (e: Exception) {&#10;                    Result.failure(Exception(&quot;Error leyendo bytes de la imagen: ${e.message}&quot;))&#10;                }&#10;            } else {&#10;                // si no hay imagen o error 404, retornar success con null para indicar ausencia&#10;                if (response.code() == 404 || response.code() == 204) {&#10;                    Result.success(null)&#10;                } else {&#10;                    val err = try { response.errorBody()?.string() } catch (_: Exception) { null }&#10;                    Result.failure(Exception(&quot;Error ${response.code()}: ${response.message()} - body=${err ?: &quot;&lt;empty&gt;&quot;}&quot;))&#10;                }&#10;            }&#10;        } catch (e: Exception) {&#10;            Result.failure(e)&#10;        }&#10;    }&#10;&#10;    suspend fun getTallasPorProducto(productoId: Long): Result&lt;List&lt;TallaDTO&gt;&gt; {&#10;        val specific = safeApiCall { productoApi.obtenerTallasPorProducto(productoId) }&#10;        if (specific.isSuccess) {&#10;            val list = specific.getOrNull() ?: emptyList()&#10;            if (list.isNotEmpty()) {&#10;                return Result.success(list)&#10;            }&#10;        }&#10;&#10;        val global = safeApiCall { productoApi.obtenerTodasLasTallas() }&#10;        if (global.isSuccess) {&#10;            return global&#10;        }&#10;        return specific.takeIf { it.isFailure } ?: global&#10;    }&#10;&#10;    suspend fun getProductoById(id: Long): Result&lt;ProductoDTO&gt; {&#10;        return safeApiCall {&#10;            productoApi.obtenerProductoPorId(id)&#10;        }&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/proyectoZapateria/viewmodel/InventarioViewModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/proyectoZapateria/viewmodel/InventarioViewModel.kt" />
              <option name="originalContent" value="package com.example.proyectoZapateria.viewmodel&#10;&#10;import android.content.Context&#10;import android.util.Log&#10;import android.widget.Toast&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import com.example.proyectoZapateria.ui.model.InventarioUi&#10;import com.example.proyectoZapateria.data.remote.inventario.dto.InventarioDTO&#10;import com.example.proyectoZapateria.data.remote.inventario.dto.ProductoDTO&#10;import com.example.proyectoZapateria.data.remote.inventario.dto.MarcaDTO&#10;import com.example.proyectoZapateria.data.remote.inventario.dto.TallaDTO&#10;import com.example.proyectoZapateria.data.repository.remote.InventarioRemoteRepository&#10;import com.example.proyectoZapateria.utils.ImageHelper&#10;import dagger.hilt.android.lifecycle.HiltViewModel&#10;import kotlinx.coroutines.flow.*&#10;import kotlinx.coroutines.launch&#10;import java.lang.Exception&#10;import javax.inject.Inject&#10;&#10;@HiltViewModel&#10;class InventarioViewModel @Inject constructor(&#10;    private val inventarioRemoteRepository: InventarioRemoteRepository&#10;) : ViewModel() {&#10;&#10;    private val _productos = MutableStateFlow&lt;List&lt;ProductoDTO&gt;&gt;(emptyList())&#10;    val productos: StateFlow&lt;List&lt;ProductoDTO&gt;&gt; = _productos&#10;&#10;    private val _marcas = MutableStateFlow&lt;List&lt;MarcaDTO&gt;&gt;(emptyList())&#10;    val marcas: StateFlow&lt;List&lt;MarcaDTO&gt;&gt; = _marcas&#10;&#10;    private val _tallas = MutableStateFlow&lt;List&lt;TallaDTO&gt;&gt;(emptyList())&#10;    val tallas: StateFlow&lt;List&lt;TallaDTO&gt;&gt; = _tallas&#10;&#10;    private val _inventarioPorModelo = MutableStateFlow&lt;List&lt;InventarioUi&gt;&gt;(emptyList())&#10;    val inventarioPorModelo: StateFlow&lt;List&lt;InventarioUi&gt;&gt; = _inventarioPorModelo&#10;&#10;    private val _imagenes = MutableStateFlow&lt;Map&lt;Long, ByteArray?&gt;&gt;(emptyMap())&#10;    val imagenes: StateFlow&lt;Map&lt;Long, ByteArray?&gt;&gt; = _imagenes&#10;&#10;    // Indica si la carga inicial de productos está en progreso&#10;    private val _isLoadingProductos = MutableStateFlow(true)&#10;    val isLoadingProductos: StateFlow&lt;Boolean&gt; = _isLoadingProductos&#10;&#10;    // Indica qué modelo está cargando su inventario (idModelo) o null si no hay carga&#10;    private val _isLoadingInventario = MutableStateFlow&lt;Long?&gt;(null)&#10;    val isLoadingInventario: StateFlow&lt;Long?&gt; = _isLoadingInventario&#10;&#10;    // cache local de productos remotos (InventarioDTO)&#10;    private var cacheInventarioRemoto: List&lt;InventarioDTO&gt; = emptyList()&#10;&#10;    init {&#10;        cargarDatosIniciales()&#10;    }&#10;&#10;    private fun cargarDatosIniciales() {&#10;        viewModelScope.launch {&#10;            // 1. Cargar Marcas desde API&#10;            inventarioRemoteRepository.getMarcas().onSuccess { dtos -&gt;&#10;                _marcas.value = dtos&#10;            }&#10;&#10;            // 2. Cargar Tallas desde API&#10;            inventarioRemoteRepository.getTallas().onSuccess { dtos -&gt;&#10;                _tallas.value = dtos.sortedBy { it.valor.toDoubleOrNull() ?: 0.0 }&#10;            }&#10;&#10;            // 3. Cargar Productos desde API&#10;            cargarProductos()&#10;        }&#10;    }&#10;&#10;    private fun cargarProductos() {&#10;        viewModelScope.launch {&#10;            // marcar inicio de carga&#10;            _isLoadingProductos.value = true&#10;&#10;            inventarioRemoteRepository.getModelos().onSuccess { dtos -&gt;&#10;                _productos.value = dtos.sortedBy { it.nombre }&#10;                _isLoadingProductos.value = false&#10;            }.onFailure {&#10;                // en fallo, dejar lista vacía y desactivar loader&#10;                _productos.value = emptyList()&#10;                _isLoadingProductos.value = false&#10;            }&#10;        }&#10;    }&#10;&#10;    // Carga el stock de un producto específico desde la NUBE&#10;    fun cargarInventarioDeModelo(idModelo: Long) {&#10;        viewModelScope.launch {&#10;            // marcar que estamos cargando este modelo&#10;            _isLoadingInventario.value = idModelo&#10;             inventarioRemoteRepository.getInventarioPorModelo(idModelo).onSuccess { dtos -&gt;&#10;                 cacheInventarioRemoto = dtos&#10;                 val listaUi = dtos.map { dto -&gt;&#10;                     val tallaLocal = _tallas.value.find { it.valor == dto.talla }&#10;                     InventarioUi(&#10;                         idRemote = dto.id ?: 0L,&#10;                         idModelo = idModelo,&#10;                         talla = dto.talla,&#10;                         tallaIdLocal = tallaLocal?.id,&#10;                         stock = dto.cantidad&#10;                     )&#10;                 }&#10;                 _inventarioPorModelo.value = listaUi&#10;                // desactivar flag de carga&#10;                _isLoadingInventario.value = null&#10;             }.onFailure {&#10;                 _inventarioPorModelo.value = emptyList()&#10;                _isLoadingInventario.value = null&#10;             }&#10;         }&#10;     }&#10;&#10;    // Actualizar Producto en la API&#10;    fun actualizarProducto(&#10;        producto: ProductoDTO,&#10;        nuevoNombre: String,&#10;        nuevoPrecio: Int,&#10;        nuevaDescripcion: String?,&#10;        nuevoIdMarca: Long&#10;    ) {&#10;        viewModelScope.launch {&#10;            val dto = ProductoDTO(&#10;                id = producto.id,&#10;                nombre = nuevoNombre,&#10;                marcaId = nuevoIdMarca,&#10;                descripcion = nuevaDescripcion,&#10;                precioUnitario = nuevoPrecio,&#10;                imagenUrl = producto.imagenUrl&#10;            )&#10;&#10;            // Manejar caso null-safe: si producto.id es null -&gt; crear, si no -&gt; actualizar&#10;            val modeloIdNullable = producto.id&#10;            if (modeloIdNullable == null) {&#10;                // Crear nuevo modelo en backend&#10;                inventarioRemoteRepository.crearModelo(dto)&#10;                    .onSuccess { cargarProductos() }&#10;                    .onFailure { /* opcional: manejar error */ }&#10;            } else {&#10;                // Actualizar modelo existente&#10;                inventarioRemoteRepository.actualizarModelo(modeloIdNullable, dto)&#10;                    .onSuccess { cargarProductos() }&#10;                    .onFailure { /* opcional: manejar error */ }&#10;            }&#10;        }&#10;    }&#10;&#10;    // Actualizar Inventario en la API (Sincronización inteligente)&#10;    fun actualizarInventario(&#10;        idModelo: Long,&#10;        inventarioPorTalla: Map&lt;Long, Int&gt;, // Map&lt;idTallaRemoto, Cantidad&gt;&#10;        context: Context,&#10;        onSuccess: () -&gt; Unit = {}&#10;    ) {&#10;        viewModelScope.launch {&#10;            try {&#10;                val modelo = _productos.value.find { it.id == idModelo }&#10;                val nombreModelo = modelo?.nombre ?: &quot;Producto&quot;&#10;&#10;                // Recorremos el mapa que viene de la UI&#10;                inventarioPorTalla.forEach { (idTallaLocal, nuevoStock) -&gt;&#10;                    // Buscamos el string de la talla (ej: &quot;40&quot;)&#10;                    val tallaObj = _tallas.value.find { it.id == idTallaLocal } ?: return@forEach&#10;                    val tallaString = tallaObj.valor&#10;&#10;                    // Verificamos si ya existe en el backend (por talla)&#10;                    val remoto = cacheInventarioRemoto.find { it.talla == tallaString }&#10;&#10;                    if (nuevoStock &lt;= 0) {&#10;                        // Si stock es 0 y existe remoto, ELIMINAR&#10;                        if (remoto != null &amp;&amp; remoto.id != null) {&#10;                            inventarioRemoteRepository.eliminarStock(remoto.id)&#10;                        }&#10;                    } else {&#10;                        val dto = InventarioDTO(&#10;                            id = remoto?.id,&#10;                            productoId = idModelo,&#10;                            nombre = nombreModelo,&#10;                            talla = tallaString,&#10;                            cantidad = nuevoStock,&#10;                            stockMinimo = 5,&#10;                            modeloId = idModelo,&#10;                            tallaId = idTallaLocal&#10;                        )&#10;&#10;                        if (remoto != null &amp;&amp; remoto.id != null) {&#10;                            // Si existe y cambió cantidad, ACTUALIZAR&#10;                            if (remoto.cantidad != nuevoStock) {&#10;                                inventarioRemoteRepository.actualizarInventario(remoto.id, dto)&#10;                            }&#10;                        } else {&#10;                            // Si no existe, CREAR&#10;                            inventarioRemoteRepository.crearInventario(dto)&#10;                        }&#10;                    }&#10;                }&#10;&#10;                Toast.makeText(context, &quot;Inventario sincronizado&quot;, Toast.LENGTH_SHORT).show()&#10;                cargarInventarioDeModelo(idModelo) // Recargar para ver cambios&#10;                onSuccess()&#10;&#10;            } catch (e: Exception) {&#10;                Toast.makeText(context, &quot;Error: ${e.message}&quot;, Toast.LENGTH_LONG).show()&#10;            }&#10;        }&#10;    }&#10;&#10;    fun eliminarProducto(context: Context, producto: ProductoDTO) {&#10;        viewModelScope.launch {&#10;            // Eliminar imagen localmente si existe (esto se mantiene local)&#10;            if (producto.imagenUrl != null) {&#10;                ImageHelper.deleteImage(context, producto.imagenUrl)&#10;            }&#10;&#10;            // Eliminar producto en la API solo si tiene id&#10;            val idToDelete = producto.id&#10;            if (idToDelete != null) {&#10;                inventarioRemoteRepository.eliminarModelo(idToDelete).onSuccess {&#10;                    Toast.makeText(context, &quot;Producto eliminado&quot;, Toast.LENGTH_SHORT).show()&#10;                    cargarProductos()&#10;                }&#10;            } else {&#10;                // Si no tiene id, solo refrescar UI&#10;                Toast.makeText(context, &quot;Producto no existe en remoto&quot;, Toast.LENGTH_SHORT).show()&#10;                cargarProductos()&#10;            }&#10;        }&#10;    }&#10;&#10;    // Buscar productos&#10;    @Suppress(&quot;unused&quot;)&#10;    fun buscarProductos(query: String) {&#10;        if (query.isBlank()) {&#10;            cargarProductos()&#10;        } else {&#10;            viewModelScope.launch {&#10;                inventarioRemoteRepository.searchModelos(query).onSuccess { dtos -&gt;&#10;                    _productos.value = dtos.sortedBy { it.nombre }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    fun loadImagenProducto(idProducto: Long) {&#10;        // No volver a pedir si ya existe (aunque sea null para indicar no hay bytes)&#10;        if (_imagenes.value.containsKey(idProducto)) return&#10;&#10;        viewModelScope.launch {&#10;            try {&#10;                val res = inventarioRemoteRepository.obtenerImagenProducto(idProducto)&#10;                if (res.isSuccess) {&#10;                    val bytes = res.getOrNull()&#10;                    _imagenes.update { map -&gt; map + (idProducto to bytes) }&#10;                } else {&#10;                    // Indicar explícitamente que no hay imagen bytes (null se usa pero guardamos clave)&#10;                    _imagenes.update { map -&gt; map + (idProducto to null) }&#10;                }&#10;            } catch (e: Exception) {&#10;                // loadImagenProducto error: ${e.message}&#10;                // Guardar clave con null para evitar reintentos continuos&#10;                _imagenes.update { map -&gt; map + (idProducto to null) }&#10;            }&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.proyectoZapateria.viewmodel&#13;&#10;&#13;&#10;import android.content.Context&#13;&#10;import android.util.Log&#13;&#10;import android.widget.Toast&#13;&#10;import androidx.lifecycle.ViewModel&#13;&#10;import androidx.lifecycle.viewModelScope&#13;&#10;import com.example.proyectoZapateria.ui.model.InventarioUi&#13;&#10;import com.example.proyectoZapateria.data.remote.inventario.dto.InventarioDTO&#13;&#10;import com.example.proyectoZapateria.data.remote.inventario.dto.ProductoDTO&#13;&#10;import com.example.proyectoZapateria.data.remote.inventario.dto.MarcaDTO&#13;&#10;import com.example.proyectoZapateria.data.remote.inventario.dto.TallaDTO&#13;&#10;import com.example.proyectoZapateria.data.repository.remote.InventarioRemoteRepository&#13;&#10;import com.example.proyectoZapateria.utils.ImageHelper&#13;&#10;import dagger.hilt.android.lifecycle.HiltViewModel&#13;&#10;import kotlinx.coroutines.flow.*&#13;&#10;import kotlinx.coroutines.launch&#13;&#10;import java.lang.Exception&#13;&#10;import javax.inject.Inject&#13;&#10;&#13;&#10;@HiltViewModel&#13;&#10;class InventarioViewModel @Inject constructor(&#13;&#10;    private val inventarioRemoteRepository: InventarioRemoteRepository&#13;&#10;) : ViewModel() {&#13;&#10;&#13;&#10;    private val _productos = MutableStateFlow&lt;List&lt;ProductoDTO&gt;&gt;(emptyList())&#13;&#10;    val productos: StateFlow&lt;List&lt;ProductoDTO&gt;&gt; = _productos&#13;&#10;&#13;&#10;    private val _marcas = MutableStateFlow&lt;List&lt;MarcaDTO&gt;&gt;(emptyList())&#13;&#10;    val marcas: StateFlow&lt;List&lt;MarcaDTO&gt;&gt; = _marcas&#13;&#10;&#13;&#10;    private val _tallas = MutableStateFlow&lt;List&lt;TallaDTO&gt;&gt;(emptyList())&#13;&#10;    val tallas: StateFlow&lt;List&lt;TallaDTO&gt;&gt; = _tallas&#13;&#10;&#13;&#10;    private val _inventarioPorModelo = MutableStateFlow&lt;List&lt;InventarioUi&gt;&gt;(emptyList())&#13;&#10;    val inventarioPorModelo: StateFlow&lt;List&lt;InventarioUi&gt;&gt; = _inventarioPorModelo&#13;&#10;&#13;&#10;    private val _imagenes = MutableStateFlow&lt;Map&lt;Long, ByteArray?&gt;&gt;(emptyMap())&#13;&#10;    val imagenes: StateFlow&lt;Map&lt;Long, ByteArray?&gt;&gt; = _imagenes&#13;&#10;&#13;&#10;    // Indica si la carga inicial de productos está en progreso&#13;&#10;    private val _isLoadingProductos = MutableStateFlow(true)&#13;&#10;    val isLoadingProductos: StateFlow&lt;Boolean&gt; = _isLoadingProductos&#13;&#10;&#13;&#10;    // Indica qué modelo está cargando su inventario (idModelo) o null si no hay carga&#13;&#10;    private val _isLoadingInventario = MutableStateFlow&lt;Long?&gt;(null)&#13;&#10;    val isLoadingInventario: StateFlow&lt;Long?&gt; = _isLoadingInventario&#13;&#10;&#13;&#10;    // cache local de productos remotos (InventarioDTO)&#13;&#10;    private var cacheInventarioRemoto: List&lt;InventarioDTO&gt; = emptyList()&#13;&#10;&#13;&#10;    init {&#13;&#10;        cargarDatosIniciales()&#13;&#10;    }&#13;&#10;&#13;&#10;    private fun cargarDatosIniciales() {&#13;&#10;        viewModelScope.launch {&#13;&#10;            // 1. Cargar Marcas desde API&#13;&#10;            inventarioRemoteRepository.getMarcas().onSuccess { dtos -&gt;&#13;&#10;                _marcas.value = dtos&#13;&#10;            }&#13;&#10;&#13;&#10;            // 2. Cargar Tallas desde API&#13;&#10;            inventarioRemoteRepository.getTallas().onSuccess { dtos -&gt;&#13;&#10;                _tallas.value = dtos.sortedBy { it.valor.toDoubleOrNull() ?: 0.0 }&#13;&#10;            }&#13;&#10;&#13;&#10;            // 3. Cargar Productos desde API&#13;&#10;            cargarProductos()&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    private fun cargarProductos() {&#13;&#10;        viewModelScope.launch {&#13;&#10;            // marcar inicio de carga&#13;&#10;            _isLoadingProductos.value = true&#13;&#10;&#13;&#10;            inventarioRemoteRepository.getModelos().onSuccess { dtos -&gt;&#13;&#10;                _productos.value = dtos.sortedBy { it.nombre }&#13;&#10;                _isLoadingProductos.value = false&#13;&#10;            }.onFailure {&#13;&#10;                // en fallo, dejar lista vacía y desactivar loader&#13;&#10;                _productos.value = emptyList()&#13;&#10;                _isLoadingProductos.value = false&#13;&#10;            }&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    // Carga el stock de un producto específico desde la NUBE&#13;&#10;    fun cargarInventarioDeModelo(idModelo: Long) {&#13;&#10;        viewModelScope.launch {&#13;&#10;            // marcar que estamos cargando este modelo&#13;&#10;            _isLoadingInventario.value = idModelo&#13;&#10;             inventarioRemoteRepository.getInventarioPorModelo(idModelo).onSuccess { dtos -&gt;&#13;&#10;                 cacheInventarioRemoto = dtos&#13;&#10;                 val listaUi = dtos.map { dto -&gt;&#13;&#10;                     val tallaLocal = _tallas.value.find { it.valor == dto.talla }&#13;&#10;                     InventarioUi(&#13;&#10;                         idRemote = dto.id ?: 0L,&#13;&#10;                         idModelo = idModelo,&#13;&#10;                         talla = dto.talla,&#13;&#10;                         tallaIdLocal = tallaLocal?.id,&#13;&#10;                         stock = dto.cantidad&#13;&#10;                     )&#13;&#10;                 }&#13;&#10;                 _inventarioPorModelo.value = listaUi&#13;&#10;                // desactivar flag de carga&#13;&#10;                _isLoadingInventario.value = null&#13;&#10;             }.onFailure {&#13;&#10;                 _inventarioPorModelo.value = emptyList()&#13;&#10;                _isLoadingInventario.value = null&#13;&#10;             }&#13;&#10;         }&#13;&#10;     }&#13;&#10;&#13;&#10;    // Actualizar Producto en la API&#13;&#10;    fun actualizarProducto(&#10;        producto: ProductoDTO,&#10;        nuevoNombre: String,&#10;        nuevoPrecio: Int,&#10;        nuevaDescripcion: String?,&#10;        nuevoIdMarca: Long&#10;    ) {&#10;        viewModelScope.launch {&#10;            val dto = ProductoDTO(&#10;                id = producto.id,&#10;                nombre = nuevoNombre.trim(),&#10;                marcaId = nuevoIdMarca,&#10;                descripcion = nuevaDescripcion?.trim()?.ifBlank { null },&#10;                precioUnitario = nuevoPrecio,&#10;                imagenUrl = producto.imagenUrl&#10;            )&#10;&#10;            val modeloIdNullable = producto.id&#10;            if (modeloIdNullable == null) {&#10;                inventarioRemoteRepository.crearModelo(dto)&#10;                    .onSuccess { &#10;                        cargarProductos()&#10;                    }&#10;                    .onFailure { error -&gt;&#10;                        android.util.Log.e(&quot;InventarioVM&quot;, &quot;Error crear: ${error.message}&quot;)&#10;                    }&#10;            } else {&#10;                inventarioRemoteRepository.actualizarModelo(modeloIdNullable, dto)&#10;                    .onSuccess { &#10;                        cargarProductos()&#10;                    }&#10;                    .onFailure { error -&gt;&#10;                        android.util.Log.e(&quot;InventarioVM&quot;, &quot;Error actualizar: ${error.message}&quot;)&#10;                    }&#10;            }&#10;        }&#10;    }&#13;&#10;&#13;&#10;    // Actualizar Inventario en la API (Sincronización inteligente)&#13;&#10;    fun actualizarInventario(&#13;&#10;        idModelo: Long,&#13;&#10;        inventarioPorTalla: Map&lt;Long, Int&gt;, // Map&lt;idTallaRemoto, Cantidad&gt;&#13;&#10;        context: Context,&#13;&#10;        onSuccess: () -&gt; Unit = {}&#13;&#10;    ) {&#13;&#10;        viewModelScope.launch {&#13;&#10;            try {&#13;&#10;                val modelo = _productos.value.find { it.id == idModelo }&#13;&#10;                val nombreModelo = modelo?.nombre ?: &quot;Producto&quot;&#13;&#10;&#13;&#10;                // Recorremos el mapa que viene de la UI&#13;&#10;                inventarioPorTalla.forEach { (idTallaLocal, nuevoStock) -&gt;&#13;&#10;                    // Buscamos el string de la talla (ej: &quot;40&quot;)&#13;&#10;                    val tallaObj = _tallas.value.find { it.id == idTallaLocal } ?: return@forEach&#13;&#10;                    val tallaString = tallaObj.valor&#13;&#10;&#13;&#10;                    // Verificamos si ya existe en el backend (por talla)&#13;&#10;                    val remoto = cacheInventarioRemoto.find { it.talla == tallaString }&#13;&#10;&#13;&#10;                    if (nuevoStock &lt;= 0) {&#13;&#10;                        // Si stock es 0 y existe remoto, ELIMINAR&#13;&#10;                        if (remoto != null &amp;&amp; remoto.id != null) {&#13;&#10;                            inventarioRemoteRepository.eliminarStock(remoto.id)&#13;&#10;                        }&#13;&#10;                    } else {&#13;&#10;                        val dto = InventarioDTO(&#13;&#10;                            id = remoto?.id,&#13;&#10;                            productoId = idModelo,&#13;&#10;                            nombre = nombreModelo,&#13;&#10;                            talla = tallaString,&#13;&#10;                            cantidad = nuevoStock,&#13;&#10;                            stockMinimo = 5,&#13;&#10;                            modeloId = idModelo,&#13;&#10;                            tallaId = idTallaLocal&#13;&#10;                        )&#13;&#10;&#13;&#10;                        if (remoto != null &amp;&amp; remoto.id != null) {&#13;&#10;                            // Si existe y cambió cantidad, ACTUALIZAR&#13;&#10;                            if (remoto.cantidad != nuevoStock) {&#13;&#10;                                inventarioRemoteRepository.actualizarInventario(remoto.id, dto)&#13;&#10;                            }&#13;&#10;                        } else {&#13;&#10;                            // Si no existe, CREAR&#13;&#10;                            inventarioRemoteRepository.crearInventario(dto)&#13;&#10;                        }&#13;&#10;                    }&#13;&#10;                }&#13;&#10;&#13;&#10;                Toast.makeText(context, &quot;Inventario sincronizado&quot;, Toast.LENGTH_SHORT).show()&#13;&#10;                cargarInventarioDeModelo(idModelo) // Recargar para ver cambios&#13;&#10;                onSuccess()&#13;&#10;&#13;&#10;            } catch (e: Exception) {&#13;&#10;                Toast.makeText(context, &quot;Error: ${e.message}&quot;, Toast.LENGTH_LONG).show()&#13;&#10;            }&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    fun eliminarProducto(context: Context, producto: ProductoDTO) {&#13;&#10;        viewModelScope.launch {&#13;&#10;            // Eliminar imagen localmente si existe (esto se mantiene local)&#13;&#10;            if (producto.imagenUrl != null) {&#13;&#10;                ImageHelper.deleteImage(context, producto.imagenUrl)&#13;&#10;            }&#13;&#10;&#13;&#10;            // Eliminar producto en la API solo si tiene id&#13;&#10;            val idToDelete = producto.id&#13;&#10;            if (idToDelete != null) {&#13;&#10;                inventarioRemoteRepository.eliminarModelo(idToDelete).onSuccess {&#13;&#10;                    Toast.makeText(context, &quot;Producto eliminado&quot;, Toast.LENGTH_SHORT).show()&#13;&#10;                    cargarProductos()&#13;&#10;                }&#13;&#10;            } else {&#13;&#10;                // Si no tiene id, solo refrescar UI&#13;&#10;                Toast.makeText(context, &quot;Producto no existe en remoto&quot;, Toast.LENGTH_SHORT).show()&#13;&#10;                cargarProductos()&#13;&#10;            }&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    // Buscar productos&#13;&#10;    @Suppress(&quot;unused&quot;)&#13;&#10;    fun buscarProductos(query: String) {&#13;&#10;        if (query.isBlank()) {&#13;&#10;            cargarProductos()&#13;&#10;        } else {&#13;&#10;            viewModelScope.launch {&#13;&#10;                inventarioRemoteRepository.searchModelos(query).onSuccess { dtos -&gt;&#13;&#10;                    _productos.value = dtos.sortedBy { it.nombre }&#13;&#10;                }&#13;&#10;            }&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    fun loadImagenProducto(idProducto: Long) {&#13;&#10;        // No volver a pedir si ya existe (aunque sea null para indicar no hay bytes)&#13;&#10;        if (_imagenes.value.containsKey(idProducto)) return&#13;&#10;&#13;&#10;        viewModelScope.launch {&#13;&#10;            try {&#13;&#10;                val res = inventarioRemoteRepository.obtenerImagenProducto(idProducto)&#13;&#10;                if (res.isSuccess) {&#13;&#10;                    val bytes = res.getOrNull()&#13;&#10;                    _imagenes.update { map -&gt; map + (idProducto to bytes) }&#13;&#10;                } else {&#13;&#10;                    // Indicar explícitamente que no hay imagen bytes (null se usa pero guardamos clave)&#13;&#10;                    _imagenes.update { map -&gt; map + (idProducto to null) }&#13;&#10;                }&#13;&#10;            } catch (e: Exception) {&#13;&#10;                // loadImagenProducto error: ${e.message}&#13;&#10;                // Guardar clave con null para evitar reintentos continuos&#13;&#10;                _imagenes.update { map -&gt; map + (idProducto to null) }&#13;&#10;            }&#13;&#10;        }&#13;&#10;    }&#13;&#10;}&#13;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>